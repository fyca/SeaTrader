<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SeaTrader dashboard</title>
  <link rel="stylesheet" href="/static/themes.css?v=20260208b" />
  <script>
    (function(){
      try {
        var t = localStorage.getItem('ui_theme') || 'classic';
        document.documentElement.dataset.theme = t;
      } catch(e) { document.documentElement.dataset.theme = 'classic'; }
      try {
        var d = localStorage.getItem('ui_density') || 'comfortable';
        document.documentElement.dataset.density = d;
      } catch(e) { document.documentElement.dataset.density = 'comfortable'; }
    })();
  </script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    body { margin: 0; }
    h1 { margin: 0 0 8px 0; }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; }
    .card h2 { font-size: 14px; margin: 0 0 8px 0; }
    .kvs { display: grid; grid-template-columns: 160px 1fr; gap: 6px 12px; font-size: 14px; }
    .accountBlocks { display:grid; grid-template-columns: repeat(12, 1fr); gap:10px; }
    .accountBlock { grid-column: span 6; }
    .accountKvs { grid-template-columns: 130px 1fr 130px 1fr !important; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { padding: 6px 8px; text-align: left; vertical-align: top; }
    .tableWrap { overflow: auto; position: relative; max-height: 360px; border: 1px solid var(--border); border-radius: var(--radius-md); }

    .ok { background: color-mix(in srgb, var(--accent-2) 14%, transparent); border-color: color-mix(in srgb, var(--accent-2) 38%, var(--border)); }
    .warn { background: color-mix(in srgb, #f59e0b 14%, transparent); border-color: color-mix(in srgb, #f59e0b 38%, var(--border)); }
    .bad { background: color-mix(in srgb, var(--danger) 12%, transparent); border-color: color-mix(in srgb, var(--danger) 34%, var(--border)); }

    tr.good td { background: color-mix(in srgb, var(--accent-2) 10%, transparent); }
    tr.exit td { background: color-mix(in srgb, var(--danger) 10%, transparent); }

    pre { white-space: pre-wrap; word-break: break-word; font-size: 12px; background: var(--panel-2); padding: 10px; border-radius: var(--radius-md); border: 1px solid var(--border); }
    .col-6 { grid-column: span 6; }
    .col-12 { grid-column: span 12; }
    @media (max-width: 900px) {
      .col-6 { grid-column: span 12; }
      .accountBlock { grid-column: span 12; }
      .accountKvs { grid-template-columns: 140px 1fr !important; }
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="topbarInner">
      <div class="brand">
        <div class="brandMark" aria-hidden="true"></div>
        <div>
          <div class="brandTitle">SeaTrader</div>
          <div class="muted" id="subtitle" style="font-size:12px; margin-top:2px;">loading…</div>
        </div>
      </div>
      <div class="row" style="align-items:center; gap:10px;">
        <a href="/" class="muted" style="text-decoration:none;" title="Dashboard"><span class="pill">Dashboard</span></a>
        <a href="/builder" class="muted" style="text-decoration:none;" title="Strategy Builder"><span class="pill">Builder</span></a>
        <div class="pill">
          <span class="muted" style="font-size:12px;">Theme</span>
          <select id="themeSel" style="padding:6px 8px;">
            <option value="classic">Classic</option>
            <option value="fun">Fun</option>
            <option value="dark">Dark</option>
          </select>
        </div>
        <div class="pill">
          <span class="muted" style="font-size:12px;">Density</span>
          <select id="densitySel" style="padding:6px 8px;">
            <option value="comfortable">Comfortable</option>
            <option value="compact">Compact</option>
          </select>
        </div>
      </div>
    </div>
  </div>
  <div class="container">

  <div class="grid" style="margin-top: 16px;">
    <div class="card col-12">
      <h2>Account</h2>
      <div class="kvs" id="account"></div>
    </div>
    <div class="card col-12">
      <h2>Bot state</h2>
      <div class="kvs" id="state"></div>
      <div style="margin-top:10px;">
        <div class="row" style="justify-content: space-between; align-items: center;">
          <div class="muted" style="margin-bottom:6px;">Strategy (applies to live + rebalance selection)</div>
          <a href="/builder" style="text-decoration:none;"><button type="button" class="secondary">Open Strategy Builder</button></a>
        </div>
        <select id="strategySelect" style="width:100%;"></select>

        <div class="muted" style="margin: 10px 0 6px 0;">Per-asset stop loss (live + risk-check)</div>
        <select id="stopLossSelect" style="width:100%;">
          <option value="">None</option>
          <option value="0.01">1%</option><option value="0.02">2%</option><option value="0.03">3%</option><option value="0.04">4%</option><option value="0.05">5%</option>
          <option value="0.06">6%</option><option value="0.07">7%</option><option value="0.08">8%</option><option value="0.09">9%</option><option value="0.10">10%</option>
          <option value="0.11">11%</option><option value="0.12">12%</option><option value="0.13">13%</option><option value="0.14">14%</option><option value="0.15">15%</option>
          <option value="0.16">16%</option><option value="0.17">17%</option><option value="0.18">18%</option><option value="0.19">19%</option><option value="0.20">20%</option>
        </select>

        <div class="muted" style="margin: 10px 0 6px 0;">Execution options (paper/live)</div>
        <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; margin-bottom:8px;">
          <div>
            <div class="muted" style="font-size:12px;">Use limit orders</div>
            <select id="useLimitOrdersSelect"><option value="false">No (market)</option><option value="true">Yes (limit)</option></select>
          </div>
          <div>
            <div class="muted" style="font-size:12px;">Limit offset (bps)</div>
            <input id="limitOffsetInput" placeholder="10" />
          </div>
          <div>
            <div class="muted" style="font-size:12px;">Weekly rebalance day</div>
            <select id="weeklyRebalanceDaySelect"><option>MON</option><option>TUE</option><option>WED</option><option>THU</option><option>FRI</option><option>SAT</option><option>SUN</option></select>
          </div>
        </div>
        <div style="display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:8px; margin-bottom:8px;">
          <div>
            <div class="muted" style="font-size:12px;">Enable pre/after-hours (equities)</div>
            <select id="extendedHoursSelect"><option value="false">No</option><option value="true">Yes</option></select>
          </div>
          <div>
            <div class="muted" style="font-size:12px;">Extended-hours start time (PT)</div>
            <input id="extendedStartTimeInput" placeholder="06:00" />
          </div>
          <div>
            <div class="muted" style="font-size:12px;">Fallback mode</div>
            <select id="fallbackEnableSelect"><option value="false">Off</option><option value="true">On (cancel unfilled limits)</option></select>
          </div>
          <div>
            <div class="muted" style="font-size:12px;">Fallback to market at (PT)</div>
            <input id="fallbackTimeInput" placeholder="06:30" />
          </div>
        </div>
        <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px;">
          <div>
            <div class="muted" style="font-size:12px;">Max orders/run</div>
            <input id="maxOrdersInput" placeholder="25 or none" />
          </div>
          <div>
            <div class="muted" style="font-size:12px;">Max single order $</div>
            <input id="maxSingleInput" placeholder="2500 or none" />
          </div>
          <div>
            <div class="muted" style="font-size:12px;">Max total/run $</div>
            <input id="maxTotalInput" placeholder="15000 or none" />
          </div>
        </div>

        <div class="muted" style="margin: 10px 0 6px 0;">Config (JSON) — edit and save</div>
        <textarea id="configEditor" style="width:100%; height:160px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 12px;"></textarea>
        <div style="display:flex; gap:8px; margin-top:8px; align-items:center;">
          <input id="token" placeholder="token (optional)" style="flex:1;" />
          <button id="saveBtn" class="primary">Save</button>
          <span id="saveStatus" class="muted"></span>
        </div>
        <div style="display:flex; gap:8px; margin-top:10px; align-items:center; flex-wrap:wrap;">
          <button id="runPaperRebalanceBtn" class="primary">Run paper rebalance</button>
          <button id="runScheduledRebalanceBtn" class="secondary">Run at configured time</button>
          <button id="runRiskCheckBtn" class="secondary">Run risk-check</button>
          <span id="runActionStatus" class="muted"></span>
        </div>
        <div style="display:flex; gap:8px; margin-top:8px; align-items:center; flex-wrap:wrap;">
          <button id="cronSetupBtn" class="secondary">Setup cron</button>
          <button id="cronRestartBtn" class="secondary">Restart cron</button>
          <button id="cronStopBtn" class="danger">Stop cron</button>
          <span id="cronStatusText" class="muted"></span>
        </div>
      </div>
    </div>

    <div class="card col-12">
      <h2>Equity curve</h2>
      <div id="equityChart" class="muted">loading…</div>
    </div>

    <div class="card col-12">
      <h2>Backtest</h2>
      <div class="muted">These dates are the evaluation window (the backtest will only score performance within this range; it may fetch earlier data as warmup for indicators).</div>

      <div class="grid" style="margin-top:10px; grid-template-columns: repeat(12, 1fr); gap:12px;">
        <div class="card col-12" style="padding:12px 14px;">
          <div class="row" style="justify-content:space-between; align-items:center;">
            <h2 style="margin:0;">Run settings</h2>
            <div class="row" style="align-items:center; gap:8px;">
              <button id="btPreset1y" class="secondary">Last 1y</button>
              <button id="btPreset5y" class="secondary">Last 5y</button>
              <input id="btSymbol" placeholder="Single symbol (optional)" style="min-width:260px;" />
              <button id="btRun" class="primary">Run backtest</button>
              <button id="btRunIter" class="secondary">Run iteration (strict)</button>
              <select id="btIterAxis" style="min-width:170px;">
                <option value="execution_time_local">Iterate buy time</option>
                <option value="risk_check_time_local">Iterate risk-check time</option>
              </select>
              <input id="btIterTimes" placeholder="06:30,07:30,08:30" value="06:30,07:30,08:30,09:30,10:30,11:30,12:30" style="min-width:320px;" />
              <label class="muted" style="display:flex; align-items:center; gap:6px;"><input id="btIterNotifyTg" type="checkbox" /> Telegram notify on completion</label>
              <button id="btClearCache" class="secondary">Clear cache</button>
              <span id="btStatus" class="muted"></span>
            </div>
          </div>

          <div class="subcard" style="margin-top:10px;">
            <div class="sectionHeader">
              <div>
                <div style="font-weight:700;">Presets</div>
                <div class="muted" style="font-size:12px; margin-top:2px;">Save/load full backtest settings. Stored in <code>config/presets.yaml</code> (unified).</div>
              </div>
              <span id="btPresetStatus" class="muted" style="font-size:12px;"></span>
            </div>

            <div class="formRow" style="margin-top:10px;">
              <div>
                <div class="label">Preset</div>
                <select id="btPreset" style="width:280px;"></select>
              </div>
              <div>
                <div class="label">New preset name</div>
                <input id="btPresetName" placeholder="e.g. weekly_safe_v2" style="min-width:240px;" />
              </div>
              <div style="flex:1;"></div>
              <button id="btPresetLoad" class="secondary">Load → UI</button>
              <button id="btPresetSave" class="secondary">Save UI → preset</button>
              <button id="btPresetUpdate" class="secondary">Update selected preset</button>
              <button id="btPresetApply" class="primary">Apply to config</button>
            </div>
          </div>

          <div style="display:flex; gap:10px; align-items:flex-end; flex-wrap: wrap; margin-top:10px;">
            <div>
              <div class="muted">Evaluation start</div>
              <input id="btStart" placeholder="YYYY-MM-DD" />
            </div>
            <div>
              <div class="muted">Evaluation end</div>
              <input id="btEnd" placeholder="YYYY-MM-DD" />
            </div>
            <div>
              <div class="muted">Strategy</div>
              <select id="btStrategy" style="width:260px;"></select>
            </div>
            <div>
              <div class="muted">Execution mode</div>
              <select id="btExecMode" style="width:180px;">
                <option value="daily" selected>Daily (open/close)</option>
                <option value="intraday">Intraday (1m bars)</option>
              </select>
            </div>
            <div>
              <div class="muted">Execution time</div>
              <select id="btExecTime" style="width:160px;">
                <option value="open">Morning (open)</option>
                <option value="close" selected>Evening (close)</option>
              </select>
            </div>
            <div>
              <div class="muted">Intraday time (PT)</div>
              <input id="btExecLocal" placeholder="HH:MM" value="15:55" style="width:120px;" />
            </div>
            <div>
              <div class="muted">Risk-check time (PT, global fallback)</div>
              <input id="btRiskTime" placeholder="HH:MM" value="12:30" style="width:170px;" />
            </div>
            <div>
              <div class="muted">Stocks risk freq</div>
              <select id="btEqRiskFreq" style="width:130px;"><option value="daily" selected>Daily</option><option value="weekly">Weekly</option></select>
            </div>
            <div>
              <div class="muted">Stocks risk day</div>
              <select id="btEqRiskDay" style="width:120px;"><option>MON</option><option>TUE</option><option>WED</option><option>THU</option><option>FRI</option><option>SAT</option><option>SUN</option></select>
            </div>
            <div>
              <div class="muted">Crypto risk freq</div>
              <select id="btCrRiskFreq" style="width:130px;"><option value="daily" selected>Daily</option><option value="weekly">Weekly</option></select>
            </div>
            <div>
              <div class="muted">Crypto risk day</div>
              <select id="btCrRiskDay" style="width:120px;"><option>MON</option><option>TUE</option><option>WED</option><option>THU</option><option>FRI</option><option>SAT</option><option>SUN</option></select>
            </div>
            <div>
              <div class="muted">Assets</div>
              <select id="btAssets" style="width:160px;">
                <option value="both" selected>Both</option>
                <option value="equities">Stocks only</option>
                <option value="crypto">Crypto only</option>
              </select>
            </div>
            <div>
              <div class="muted">Stocks rebalance freq</div>
              <select id="btEqRebFreq" style="width:140px;"><option value="weekly" selected>Weekly</option><option value="daily">Daily</option></select>
            </div>
            <div>
              <div class="muted">Stocks rebalance day</div>
              <select id="btEqRebDay" style="width:120px;"><option>MON</option><option>TUE</option><option>WED</option><option>THU</option><option>FRI</option><option>SAT</option><option>SUN</option></select>
            </div>
            <div>
              <div class="muted">Crypto rebalance freq</div>
              <select id="btCrRebFreq" style="width:140px;"><option value="weekly" selected>Weekly</option><option value="daily">Daily</option></select>
            </div>
            <div>
              <div class="muted">Crypto rebalance day</div>
              <select id="btCrRebDay" style="width:120px;"><option>MON</option><option>TUE</option><option>WED</option><option>THU</option><option>FRI</option><option>SAT</option><option>SUN</option></select>
            </div>
            <div>
              <div class="muted">Slippage (bps)</div>
              <input id="btSlip" placeholder="10" value="10" style="width:120px;" />
            </div>
            <div>
              <div class="muted">Use limit orders (global fallback)</div>
              <select id="btUseLimit" style="width:190px;"><option value="false" selected>No (market)</option><option value="true">Yes (limit)</option></select>
            </div>
            <div>
              <div class="muted">Limit offset (bps, global fallback)</div>
              <input id="btLimitOffset" placeholder="10" value="10" style="width:170px;" />
            </div>
            <div>
              <div class="muted">Stocks order type</div>
              <select id="btEqOrderType" style="width:130px;"><option value="market">Market</option><option value="limit">Limit</option></select>
            </div>
            <div>
              <div class="muted">Stocks offset bps</div>
              <input id="btEqLimitOffset" placeholder="10" value="10" style="width:120px;" />
            </div>
            <div>
              <div class="muted">Crypto order type</div>
              <select id="btCrOrderType" style="width:130px;"><option value="market">Market</option><option value="limit">Limit</option></select>
            </div>
            <div>
              <div class="muted">Crypto offset bps</div>
              <input id="btCrLimitOffset" placeholder="10" value="10" style="width:120px;" />
            </div>
            <div>
              <div class="muted">Limit fallback</div>
              <select id="btLimitFallback" style="width:190px;"><option value="false" selected>Off</option><option value="true">Fallback to market @ open</option></select>
            </div>
            <div>
              <div class="muted">Fallback time (PT)</div>
              <input id="btLimitFallbackTime" placeholder="06:30" value="06:30" style="width:120px;" />
            </div>
            <!-- single symbol moved to header actions row -->
          </div>
        </div>

        <div class="card col-12" style="padding:12px 14px;">
          <h2 style="margin:0 0 10px 0;">Portfolio construction</h2>
          <div style="display:flex; gap:10px; align-items:flex-end; flex-wrap: wrap;">
            <div>
              <div class="muted">Rebalance frequency</div>
              <select id="btRebalance" style="width:160px;">
                <option value="weekly" selected>Weekly</option>
                <option value="daily">Daily</option>
              </select>
            </div>
            <div>
              <div class="muted">Weekly day</div>
              <select id="btRebalanceDay" style="width:120px;">
                <option>MON</option><option>TUE</option><option>WED</option><option>THU</option><option>FRI</option><option>SAT</option><option>SUN</option>
              </select>
            </div>
            <div>
              <div class="muted">Rebalance style</div>
              <select id="btRebalanceMode" style="width:200px;">
                <option value="target_notional" selected>Target % notional</option>
                <option value="no_add_to_losers">Don't add to losers</option>
              </select>
            </div>
            <div>
              <div class="muted">Liquidation</div>
              <select id="btLiquidation" style="width:220px;">
                <option value="liquidate_non_selected" selected>Liquidate non-selected</option>
                <option value="hold_until_exit">Hold until exit signal</option>
              </select>
            </div>
            <div>
              <div class="muted">Per-asset stop loss</div>
              <select id="btStopLoss" style="width:180px;">
                <option value="">None</option>
                <option value="0.01">1%</option><option value="0.02">2%</option><option value="0.03">3%</option><option value="0.04">4%</option><option value="0.05">5%</option>
                <option value="0.06">6%</option><option value="0.07">7%</option><option value="0.08">8%</option><option value="0.09">9%</option><option value="0.10">10%</option>
                <option value="0.11">11%</option><option value="0.12">12%</option><option value="0.13">13%</option><option value="0.14">14%</option><option value="0.15">15%</option>
                <option value="0.16">16%</option><option value="0.17">17%</option><option value="0.18">18%</option><option value="0.19">19%</option><option value="0.20">20%</option>
              </select>
            </div>
            <div>
              <div class="muted">Max drawdown stop</div>
              <select id="btDDPreset" style="width:180px;">
                <option value="">None</option>
                <option value="0.20" selected>20%</option>
                <option value="0.30">30%</option>
                <option value="0.40">40%</option>
                <option value="0.50">50%</option>
              </select>
            </div>
            <div>
              <div class="muted">Custom DD stop</div>
              <input id="btDD" placeholder="e.g. 0.25" style="width:160px;" />
            </div>
            <div>
              <div class="muted">Exclude if symbol P/L % &lt;=</div>
              <input id="btSymFloor" placeholder="e.g. -0.005" value="-0.005" style="width:160px;" />
              <label class="muted" style="display:block; margin-top:4px;">
                <input id="btSymFloorLiquidate" type="checkbox" checked /> Immediately liquidate when excluded
              </label>
              <label class="muted" style="display:block; margin-top:2px;">
                <input id="btSymFloorInclUnreal" type="checkbox" checked /> Include unrealized P/L (recommended)
              </label>
            </div>
            <div>
              <div class="muted">Hover holdings list</div>
              <select id="btHoldMode" style="width:180px;">
                <option value="top" selected>Top 15 by value</option>
                <option value="bottom">Bottom 15 by value</option>
              </select>
            </div>
          </div>
        </div>
      </div>
      <div id="btMetrics" class="muted" style="margin-top:8px;"></div>
      <div class="muted" id="btParams" style="margin-top:6px;"></div>
      <div id="btIterSummary" class="muted" style="margin-top:8px;"></div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px;">
        <select id="btIterBestMetric" style="min-width:190px;">
          <option value="sharpe">Best Sharpe (max)</option>
          <option value="return">Best Return (max)</option>
          <option value="max_drawdown_min">Best Max DD (min)</option>
        </select>
        <button id="btIterExportCsv" class="secondary">Export iteration CSV</button>
        <select id="btIterReportSel" style="min-width:280px;"></select>
        <button id="btIterReportLoad" class="secondary">Load saved report</button>
      </div>
      <div id="btChart" class="muted" style="margin-top:8px;">(no results yet)</div>
      <div style="margin-top:10px;">
        <h2>Open positions at end (unrealized)</h2>
        <div class="tableWrap">
          <table>
            <thead>
              <tr><th>Symbol</th><th>Qty</th><th>Avg cost</th><th>Last close</th><th>Value</th><th>Unrealized P/L</th><th>Unrealized %</th></tr>
            </thead>
            <tbody id="btOpenPos"></tbody>
          </table>
        </div>
      </div>

      <div style="margin-top:10px;">
        <h2>P/L by symbol (realized)</h2>
        <div class="muted" style="margin-top:4px;">Click the P/L header to sort ascending/descending.</div>
        <div class="tableWrap" style="margin-top:6px;">
          <table>
            <thead>
              <tr>
                <th>Symbol</th>
                <th>Trades</th>
                <th>Realized</th>
                <th>Unrealized (end)</th>
                <th id="btSymPnlSort" style="cursor:pointer;">Total ▾</th>
              </tr>
            </thead>
            <tbody id="btSymPnl"></tbody>
          </table>
        </div>
        <div id="btSymDetail" class="muted" style="margin-top:8px;">(click a symbol to view its chart + trades)</div>
      </div>

      <div style="margin-top:10px;">
        <div class="row" style="justify-content:space-between; align-items:center; margin-bottom:6px;">
          <h2 style="margin:0;">Trades (realized)</h2>
          <input id="btTradeSearch" placeholder="Search symbol(s): AAPL, BTC/USD" style="min-width:280px;" />
        </div>
        <div class="tableWrap">
          <table>
            <thead>
              <tr><th>Symbol</th><th>Entry</th><th>Exit</th><th>Qty</th><th>Entry Px</th><th>Exit Px</th><th>P/L</th><th>P/L %</th><th>Reason</th></tr>
            </thead>
            <tbody id="btTrades"></tbody>
          </table>
        </div>
      </div>
      <!-- backtest presets moved to top -->

      <div style="margin-top:10px;">
        <div class="row" style="justify-content:space-between; align-items:center; margin-bottom:6px;">
          <h2 style="margin:0;">Daily ledger (by date)</h2>
          <input id="btLedgerSearch" placeholder="Filter days by symbol(s): AAPL, BTC/USD" style="min-width:320px;" />
        </div>
        <div class="muted" style="margin-top:4px;">Cash/equity shown are end-of-day marks from the backtest engine. Starting-of-day is prior day end. Click a row to expand the day’s buys/sells.</div>
        <div class="tableWrap" style="margin-top:6px; max-height:360px;">
          <table>
            <thead>
              <tr>
                <th></th>
                <th>Date</th>
                <th>Cash start</th>
                <th>Cash end</th>
                <th>Equity start</th>
                <th>Equity end</th>
                <th>Invested start</th>
                <th>Invested end</th>
                <th>Buys</th>
                <th>Sells</th>
                <th>Net</th>
                <th>Events</th>
              </tr>
            </thead>
            <tbody id="btLedger"></tbody>
          </table>
        </div>
      </div>

      <div class="muted" style="margin-top:6px;">Note: backtest runs in the background and uses daily prices; it can take a bit.</div>
      <div style="margin-top:10px;">
        <h2>Backtest history</h2>
        <div class="tableWrap">
          <table>
            <thead>
              <tr><th>Job</th><th>State</th><th>Progress</th><th>Error</th><th></th></tr>
            </thead>
            <tbody id="btJobs"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="card col-12">
      <h2>Exposure (held + pending orders)</h2>
      <table>
        <thead>
          <tr>
            <th></th>
            <th>Symbol</th>
            <th>Held Qty</th>
            <th>Market Value</th>
            <th>Pending Buy Qty</th>
            <th>Pending Buy $</th>
            <th>Est Price</th>
            <th>Est Qty (from $)</th>
            <th>Pending Sell Qty</th>
            <th>Pending Sell $</th>
            <th>Avg Entry</th>
            <th>Unrealized P/L</th>
            <th>Unrealized %</th>
          </tr>
        </thead>
        <tbody id="exposure"></tbody>
      </table>
      <div class="muted" style="margin-top:8px;">Click a row to expand open orders for that symbol.</div>
    </div>

    <div class="card col-12">
      <h2>Last run summary</h2>
      <div class="grid">
        <div class="card col-6">
          <h2>Last rebalance</h2>
          <div class="kvs" id="rebalanceSummary"></div>
          <div style="margin-top:10px;">
            <h2>Entry signals (selected)</h2>
            <div class="tableWrap">
              <table>
                <thead>
                  <tr><th>Symbol</th><th>Score</th><th>Close</th><th>MA long</th><th>Ann vol</th></tr>
                </thead>
                <tbody id="entrySignals"></tbody>
              </table>
            </div>
          </div>
          <div style="margin-top:8px;"><details><summary class="muted">Raw JSON</summary><pre id="rebalance"></pre></details></div>
        </div>
        <div class="card col-6">
          <h2>Last risk check</h2>
          <div class="kvs" id="riskSummary"></div>
          <div style="margin-top:10px;">
            <h2>Exit signals</h2>
            <div class="tableWrap">
              <table>
                <thead>
                  <tr><th>Symbol</th><th>Asset</th><th>Reason</th><th>Close</th><th>MA long</th></tr>
                </thead>
                <tbody id="exitSignals"></tbody>
              </table>
            </div>
          </div>
          <div style="margin-top:8px;"><details><summary class="muted">Raw JSON</summary><pre id="risk"></pre></details></div>
        </div>
      </div>
    </div>

    <div class="card col-12">
      <h2>Orders</h2>
      <div class="muted" id="orderSummary" style="margin: 6px 0 10px 0;">loading…</div>
      <div style="display:flex; gap:8px; margin-bottom:10px; align-items:center;">
        <button id="cancelAllBtn" class="danger">Cancel all open orders (paper)</button>
        <span id="cancelStatus" class="muted"></span>
      </div>
      <div class="grid">
        <div class="col-6">
          <h2>Open orders</h2>
          <div class="tableWrap">
            <table>
              <thead>
                <tr><th>Symbol</th><th>Side</th><th>Status</th><th>Type</th><th>Notional</th><th>Qty</th><th>Limit</th><th>Stop</th><th>Created</th></tr>
              </thead>
              <tbody id="openOrders"></tbody>
            </table>
          </div>
        </div>
        <div class="col-6">
          <h2>Recent fills</h2>
          <div class="tableWrap">
            <table>
              <thead>
                <tr><th>Symbol</th><th>Side</th><th>Filled Qty</th><th>Expected Px</th><th>Filled Avg Px</th><th>Slippage vs Expected</th><th>Filled At</th></tr>
              </thead>
              <tbody id="recentFills"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="card col-12">
      <h2>Last placed orders</h2>
      <table>
        <thead>
          <tr><th>Symbol</th><th>Side</th><th>Notional</th><th>Id</th></tr>
        </thead>
        <tbody id="lastPlaced"></tbody>
      </table>
    </div>
  </div>
</div>

<script>
async function getJSON(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(url + " -> " + r.status);
  return await r.json();
}

async function postJSON(url, body) {
  const r = await fetch(url, {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify(body || {})
  });
  if (!r.ok) {
    let t = '';
    try { t = await r.text(); } catch(e) {}
    throw new Error(url + ' -> ' + r.status + (t ? (': ' + t.slice(0,200)) : ''));
  }
  return await r.json();
}

function money(x) {
  if (x === null || x === undefined || Number.isNaN(x)) return "—";
  return "$" + Number(x).toLocaleString(undefined, {maximumFractionDigits: 2, minimumFractionDigits: 2});
}

function pct(x) {
  if (x === null || x === undefined || Number.isNaN(x)) return "—";
  return (100*Number(x)).toFixed(2) + "%";
}

function computeRSI(values, period=14) {
  // Simple RSI using rolling average of gains/losses (SMA method)
  if (!values || values.length < period + 2) return [];
  const deltas = [];
  for (let i=1;i<values.length;i++) deltas.push(values[i]-values[i-1]);
  const rsi = new Array(values.length).fill(null);

  for (let i=period; i<values.length; i++) {
    // deltas index is i-1
    let gain=0, loss=0;
    for (let j=i-period; j<i; j++) {
      const d = deltas[j];
      if (d>=0) gain += d;
      else loss += (-d);
    }
    const avgGain = gain / period;
    const avgLoss = loss / period;
    if (avgLoss === 0) {
      rsi[i] = 100;
    } else {
      const rs = avgGain / avgLoss;
      rsi[i] = 100 - (100 / (1 + rs));
    }
  }
  return rsi;
}

function kv(el, k, v) {
  const kEl = document.createElement('div');
  kEl.textContent = k;
  kEl.className = 'muted';
  const vEl = document.createElement('div');
  vEl.textContent = v;
  el.appendChild(kEl);
  el.appendChild(vEl);
}

function fmtDate(d) {
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  return `${yyyy}-${mm}-${dd}`;
}

let btJobId = null;

function setBacktestDatesYears(years) {
  const end = new Date();
  const start = new Date();
  start.setFullYear(end.getFullYear() - years);
  const sEl = document.getElementById('btStart');
  const eEl = document.getElementById('btEnd');
  if (sEl) sEl.value = fmtDate(start);
  if (eEl) eEl.value = fmtDate(end);
}

function setDefaultBacktestDates() {
  const sEl = document.getElementById('btStart');
  const eEl = document.getElementById('btEnd');
  if (sEl && eEl && !sEl.value && !eEl.value) {
    setBacktestDatesYears(1);
  }
}

function collectBacktestRequestBody() {
  const start = document.getElementById('btStart')?.value;
  const end = document.getElementById('btEnd')?.value;
  const strategy_id = (document.getElementById('btStrategy')?.value || 'baseline_trendvol');
  const execution_time_mode = (document.getElementById('btExecMode')?.value || 'daily');
  const execution_time = (document.getElementById('btExecTime')?.value || 'close');
  const execution_time_local = (document.getElementById('btExecLocal')?.value || '15:55');
  const risk_check_time_local = (document.getElementById('btRiskTime')?.value || '12:30');
  const execution_tz = 'America/Los_Angeles';
  const asset_mode = (document.getElementById('btAssets')?.value || 'both');
  const rebalance = (document.getElementById('btRebalance')?.value || 'weekly');
  const rebalance_day = (document.getElementById('btRebalanceDay')?.value || 'MON');
  const rebalance_frequency_equities = (document.getElementById('btEqRebFreq')?.value || rebalance);
  const rebalance_day_equities = (document.getElementById('btEqRebDay')?.value || rebalance_day);
  const rebalance_frequency_crypto = (document.getElementById('btCrRebFreq')?.value || rebalance);
  const rebalance_day_crypto = (document.getElementById('btCrRebDay')?.value || rebalance_day);
  const risk_check_frequency_equities = (document.getElementById('btEqRiskFreq')?.value || 'daily');
  const risk_check_day_equities = (document.getElementById('btEqRiskDay')?.value || rebalance_day);
  const risk_check_frequency_crypto = (document.getElementById('btCrRiskFreq')?.value || 'daily');
  const risk_check_day_crypto = (document.getElementById('btCrRiskDay')?.value || rebalance_day);
  const rebalance_mode = (document.getElementById('btRebalanceMode')?.value || 'target_notional');
  const liquidation_mode = (document.getElementById('btLiquidation')?.value || 'liquidate_non_selected');
  const slippage_bps = Number(document.getElementById('btSlip')?.value || '10');
  const use_limit_orders = String(document.getElementById('btUseLimit')?.value || 'false') === 'true';
  const limit_offset_bps = Number(document.getElementById('btLimitOffset')?.value || '10');
  const order_type_equities = String(document.getElementById('btEqOrderType')?.value || 'market');
  const order_type_crypto = String(document.getElementById('btCrOrderType')?.value || 'market');
  const limit_offset_bps_equities = Number(document.getElementById('btEqLimitOffset')?.value || '10');
  const limit_offset_bps_crypto = Number(document.getElementById('btCrLimitOffset')?.value || '10');
  const symbol = (document.getElementById('btSymbol')?.value || '').trim();
  const stopLoss = (document.getElementById('btStopLoss')?.value || '').trim();
  const symFloorRaw = (document.getElementById('btSymFloor')?.value || '').trim();
  const symbol_pnl_floor_pct = symFloorRaw ? Number(symFloorRaw) : null;
  const symbol_pnl_floor_liquidate = Boolean(document.getElementById('btSymFloorLiquidate')?.checked);
  const symbol_pnl_floor_include_unrealized = Boolean(document.getElementById('btSymFloorInclUnreal')?.checked);
  const per_asset_stop_loss_pct = stopLoss ? Number(stopLoss) : null;
  const ddCustom = (document.getElementById('btDD')?.value || '').trim();
  const ddPreset = (document.getElementById('btDDPreset')?.value || '').trim();
  const ddStopRaw = ddCustom || ddPreset;
  const portfolio_dd_stop = ddStopRaw ? Number(ddStopRaw) : null;
  const limit_fallback_to_market_open = String(document.getElementById('btLimitFallback')?.value || 'false') === 'true';
  const limit_fallback_time_local = (document.getElementById('btLimitFallbackTime')?.value || '06:30');

  return {
    start, end, slippage_bps, use_limit_orders, limit_offset_bps,
    order_type_equities, order_type_crypto, limit_offset_bps_equities, limit_offset_bps_crypto,
    limit_fallback_to_market_open, limit_fallback_time_local,
    initial_equity: 100000, strategy_id, execution_time_mode, execution_time,
    execution_time_local, risk_check_time_local, execution_tz, asset_mode,
    rebalance, rebalance_day,
    rebalance_frequency_equities, rebalance_day_equities,
    rebalance_frequency_crypto, rebalance_day_crypto,
    risk_check_frequency_equities, risk_check_day_equities,
    risk_check_frequency_crypto, risk_check_day_crypto,
    rebalance_mode, liquidation_mode,
    universe_mode: symbol ? 'single' : 'full', symbol: symbol || null,
    portfolio_dd_stop, per_asset_stop_loss_pct,
    symbol_pnl_floor_pct, symbol_pnl_floor_liquidate, symbol_pnl_floor_include_unrealized
  };
}

async function runBacktest() {
  const status = document.getElementById('btStatus');
  const token = document.getElementById('token')?.value || '';
  status.textContent = 'starting…';
  const body = collectBacktestRequestBody();
  const r = await fetch('/api/backtest/start' + (token ? ('?token=' + encodeURIComponent(token)) : ''), {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify(body)
  });
  if (!r.ok) throw new Error(await r.text());
  const j = await r.json();
  btJobId = j.job_id;
  status.textContent = `job ${btJobId} started`;
}

function parseIterTimes(raw) {
  return String(raw || '')
    .split(/[\s,]+/)
    .map(s => s.trim())
    .filter(Boolean);
}

window.__btIterRows = [];
window.__btIterAxis = 'execution_time_local';

function renderIterationSummary(rows, axis) {
  window.__btIterRows = rows || [];
  window.__btIterAxis = axis || 'execution_time_local';
  const el = document.getElementById('btIterSummary');
  if (!el) return;
  if (!rows.length) {
    el.textContent = '';
    return;
  }
  const axisLabel = axis === 'execution_time_local' ? 'Buy time' : 'Risk-check time';
  const head = `<div style="margin-bottom:6px;"><b>Iteration summary</b> (${axisLabel}) — ${rows.length} complete</div>`;
  const table = `<div class="tableWrap" style="max-height:260px;"><table><thead><tr><th>${axisLabel}</th><th>State</th><th>Return</th><th>Max DD</th><th>Sharpe</th><th>Job</th></tr></thead><tbody>`
    + rows.map(r => `<tr><td>${r.iter_value}</td><td>${r.state}</td><td>${r.ret ?? '—'}</td><td>${r.dd ?? '—'}</td><td>${r.sh ?? '—'}</td><td style="font-family:ui-monospace,monospace;font-size:11px;">${r.job_id || '—'}</td></tr>`).join('')
    + `</tbody></table></div>`;
  el.innerHTML = head + table;
}

function pickBestIteration(rows, metricKey) {
  const done = (rows || []).filter(r => r.state === 'done' && r.metrics);
  if (!done.length) return null;
  if (metricKey === 'max_drawdown_min') {
    return done.reduce((a,b) => (Number(b.metrics.max_drawdown ?? 1e9) < Number(a.metrics.max_drawdown ?? 1e9) ? b : a));
  }
  if (metricKey === 'return') {
    return done.reduce((a,b) => (Number(b.metrics.return ?? -1e9) > Number(a.metrics.return ?? -1e9) ? b : a));
  }
  return done.reduce((a,b) => (Number(b.metrics.sharpe ?? -1e9) > Number(a.metrics.sharpe ?? -1e9) ? b : a));
}

async function refreshIterationReportsList(selectedId='') {
  const sel = document.getElementById('btIterReportSel');
  if (!sel) return;
  try {
    const j = await getJSON('/api/backtest/iterations/list?limit=50');
    sel.innerHTML = '';
    for (const it of (j.reports || [])) {
      const opt = document.createElement('option');
      opt.value = it.id;
      opt.textContent = `${it.created_at || ''} • ${it.asset_mode || '—'} • ${it.axis || '—'} • ${it.count || 0} rows`;
      sel.appendChild(opt);
    }
    if (selectedId) sel.value = selectedId;
  } catch (e) {
    // ignore silently
  }
}

async function saveIterationReport(rows, axis) {
  const token = document.getElementById('token')?.value || '';
  const body = collectBacktestRequestBody();
  const metric = document.getElementById('btIterBestMetric')?.value || 'sharpe';
  const best = pickBestIteration(rows, metric);
  const report = {
    axis,
    metric,
    best: best ? {iter_value: best.iter_value, ret: best.ret, dd: best.dd, sh: best.sh, job_id: best.job_id} : null,
    asset_mode: body.asset_mode,
    start: body.start,
    end: body.end,
    settings: body,
    rows,
  };
  const r = await fetch('/api/backtest/iterations/save' + (token ? ('?token=' + encodeURIComponent(token)) : ''), {
    method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(report)
  });
  if (!r.ok) throw new Error(await r.text());
  const j = await r.json();
  await refreshIterationReportsList(j.id || '');
  return j;
}

async function loadIterationReportById(id) {
  if (!id) return;
  const j = await getJSON('/api/backtest/iterations/get?id=' + encodeURIComponent(id));
  const rep = j.report || {};
  const rows = rep.rows || [];
  const axis = rep.axis || 'execution_time_local';
  renderIterationSummary(rows, axis);
  const mSel = document.getElementById('btIterBestMetric');
  if (mSel && rep.metric) mSel.value = rep.metric;
  const status = document.getElementById('btStatus');
  if (status) status.textContent = `loaded report ${id} (${rows.length} rows)`;
}

function exportIterationCsv() {
  const rows = window.__btIterRows || [];
  if (!rows.length) {
    const status = document.getElementById('btStatus');
    if (status) status.textContent = 'no iteration rows to export';
    return;
  }
  const header = ['iter_axis','iter_value','state','job_id','return','max_drawdown','sharpe'];
  const axis = window.__btIterAxis || 'execution_time_local';
  const lines = [header.join(',')];
  for (const r of rows) {
    const m = r.metrics || {};
    const vals = [axis, r.iter_value, r.state, r.job_id || '', m.return ?? '', m.max_drawdown ?? '', m.sharpe ?? ''];
    lines.push(vals.map(v => {
      const s = String(v ?? '');
      return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
    }).join(','));
  }
  const blob = new Blob([lines.join('\n')], {type:'text/csv;charset=utf-8;'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'backtest_iteration_summary.csv';
  a.click();
  URL.revokeObjectURL(a.href);
}

async function waitBacktestJob(jobId, onTick) {
  while (true) {
    const st = await getJSON('/api/backtest/status?job_id=' + encodeURIComponent(jobId));
    if (onTick) onTick(st);
    if (st.state === 'done' || st.state === 'error' || st.state === 'missing') return st;
    await new Promise(res => setTimeout(res, 1200));
  }
}

async function runBacktestIteration() {
  const status = document.getElementById('btStatus');
  const token = document.getElementById('token')?.value || '';
  const axis = document.getElementById('btIterAxis')?.value || 'execution_time_local';
  const times = parseIterTimes(document.getElementById('btIterTimes')?.value || '');
  if (!times.length) {
    status.textContent = 'enter at least one time (e.g. 06:30,07:30)';
    return;
  }

  const rows = [];
  renderIterationSummary(rows, axis);

  for (let i=0;i<times.length;i++) {
    const t = times[i];
    const body = collectBacktestRequestBody();
    body[axis] = t;
    status.textContent = `iteration ${i+1}/${times.length}: starting ${axis}=${t}…`;

    const r = await fetch('/api/backtest/start' + (token ? ('?token=' + encodeURIComponent(token)) : ''), {
      method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body)
    });
    if (!r.ok) throw new Error(await r.text());
    const j = await r.json();
    const jobId = j.job_id;

    const st = await waitBacktestJob(jobId, (x) => {
      status.textContent = `iteration ${i+1}/${times.length}: ${t} • ${x.state} ${x.progress||0}/${x.total||0}`;
    });

    if (st.state !== 'done') {
      rows.push({iter_value: t, state: st.state || 'error', ret: '—', dd: '—', sh: '—', job_id: jobId});
      renderIterationSummary(rows, axis);
      status.textContent = `iteration stopped at ${t}: ${st.state || 'error'}`;
      break;
    }

    const res = await getJSON('/api/backtest/result?job_id=' + encodeURIComponent(jobId));
    await renderBacktest(res);
    const m = res.metrics || {};
    rows.push({
      iter_value: t,
      state: 'done',
      ret: pct(m.return),
      dd: pct(m.max_drawdown),
      sh: Number(m.sharpe||0).toFixed(3),
      job_id: jobId,
      metrics: { return: m.return, max_drawdown: m.max_drawdown, sharpe: m.sharpe }
    });
    renderIterationSummary(rows, axis);
    status.textContent = `iteration ${i+1}/${times.length} done: ${t}`;
  }

  const doneCount = rows.filter(r => r.state === 'done').length;
  let reportId = '';
  try {
    const saved = await saveIterationReport(rows, axis);
    reportId = saved.id || '';
  } catch (e) {
    // leave as-is; user still has in-page summary/csv
  }
  status.textContent = `iteration complete: ${doneCount}/${times.length} done${reportId ? ' • report ' + reportId : ''}`;

  if (document.getElementById('btIterNotifyTg')?.checked) {
    const metric = document.getElementById('btIterBestMetric')?.value || 'sharpe';
    const best = pickBestIteration(rows, metric);
    const axisLabel = axis === 'execution_time_local' ? 'buy time' : 'risk-check time';
    const note = best
      ? `SeaTrader iteration complete (${doneCount}/${times.length}). Best ${axisLabel}: ${best.iter_value} | return ${best.ret} | maxDD ${best.dd} | sharpe ${best.sh}.${reportId ? ' Report: ' + reportId + '.' : ''}`
      : `SeaTrader iteration complete (${doneCount}/${times.length}).${reportId ? ' Report: ' + reportId + '.' : ''}`;
    try {
      await postJSON('/api/backtest/notify-telegram', {text: note});
      status.textContent += ' • telegram sent';
    } catch (e) {
      status.textContent += ' • telegram notify failed';
    }
  }
}

async function pollBacktest() {
  if (!btJobId) return;
  const st = await getJSON('/api/backtest/status?job_id=' + encodeURIComponent(btJobId));
  const el = document.getElementById('btStatus');
  if (st.state === 'running' || st.state === 'fetching_data' || st.state === 'fetching_crypto') {
    el.textContent = `${st.state} ${st.progress||0}/${st.total||0}`;
  }
  if (st.state === 'done') {
    el.textContent = 'done';
    const res = await getJSON('/api/backtest/result?job_id=' + encodeURIComponent(btJobId));
    await renderBacktest(res);
    btJobId = null;
  }
  if (st.state === 'error') {
    el.textContent = 'error: ' + st.error;
    const met = document.getElementById('btMetrics');
    if (st.traceback) met.textContent = st.traceback;
    btJobId = null;
  }
}

async function renderBacktest(res) {
  window.__lastBacktestRes = res;
  const m = res.metrics || {};
  const met = document.getElementById('btMetrics');
  met.textContent = `Return: ${pct(m.return)} • CAGR: ${pct(m.cagr)} • Max DD: ${pct(m.max_drawdown)} • Obs DD: ${pct(m.max_observed_drawdown)} • Ann vol: ${pct(m.ann_vol)} • Sharpe: ${Number(m.sharpe||0).toFixed(2)} • Trades: ${m.trade_count ?? '—'} • Win rate: ${m.win_rate==null ? '—' : pct(m.win_rate)} • DD-stop events: ${m.dd_stop_event_count ?? 0} • Start: ${money(m.start_equity)} • End: ${money(m.end_equity)}`;

  const evs = (res.events || []);
  const cPlaced = evs.filter(e => e.type==='order' && e.reason==='limit_placed').length;
  const cLimitFill = evs.filter(e => (e.reason==='limit_fill')).length;
  const cFallback = evs.filter(e => (e.reason==='limit_fallback_market_open')).length;
  const cCanceled = evs.filter(e => (e.type==='cancel' && e.reason==='limit_cancel_next_rebalance')).length;
  const cBuy = evs.filter(e => e.type==='buy').length;
  const cSell = evs.filter(e => e.type==='sell').length;
  const cFilled = cLimitFill + cFallback;
  const fillRate = cPlaced>0 ? (100*cFilled/cPlaced) : null;

  let life = document.getElementById('btOrderLifecycle');
  if (!life) {
    life = document.createElement('div');
    life.id = 'btOrderLifecycle';
    life.className = 'muted';
    life.style.marginTop = '6px';
    met.insertAdjacentElement('afterend', life);
  }
  life.textContent = `Order lifecycle: placed ${cPlaced} • filled ${cFilled} (${fillRate==null?'—':fillRate.toFixed(1)+'%'}) • limit fills ${cLimitFill} • fallback market fills ${cFallback} • canceled(next rebalance) ${cCanceled} • buy events ${cBuy} • sell events ${cSell}`;

  const p = res.params || {};
  const bp = document.getElementById('btParams');
  if (bp) {
    bp.textContent = `Params: strategy=${p.strategy_id||'—'} • assets=${p.asset_mode||'—'} • rebalance=${p.rebalance||'—'} • style=${p.rebalance_mode||'—'} • liquidation=${p.liquidation_mode||'—'} • stopLoss=${p.per_asset_stop_loss_pct ?? 'none'} • ddStop=${p.portfolio_dd_stop ?? 'none'} • slippage=${p.slippage_bps ?? '—'}bps • window=${p.start||'—'}→${p.end||'—'}`;
  }

  const curve = res.equity_curve || [];
  const ec = document.getElementById('btChart');
  if (curve.length < 2) { ec.textContent='(no curve)'; return; }

  // Benchmarks (SPY + S&P500) normalized to 100 at start
  const start = curve[0].date;
  const end = curve[curve.length-1].date;
  let bm = null;
  try {
    bm = await getJSON('/api/benchmarks?start=' + encodeURIComponent(start) + '&end=' + encodeURIComponent(end));
  } catch (e) {
    bm = null;
  }

  const x = curve.map(p => p.date);
  const y = curve.map(p => Number(p.equity));
  const cash = curve.map(p => Number(p.cash || 0));
  const unreal = curve.map(p => Number(p.unrealized_pnl || 0));
  const base = y[0] || 1;
  const yN = y.map(v => (v/base)*100.0);

  const holdModeEl = document.getElementById('btHoldMode');
  const holdMode = holdModeEl ? (holdModeEl.value || 'top') : 'top';

  const holdText = curve.map(p => {
    let hs = (p.holdings || []);
    if (!hs.length) return '(no positions)';
    // holdings are stored sorted by mv desc; if bottom mode, invert and take 15
    if (holdMode === 'bottom') {
      hs = [...hs].sort((a,b)=>Math.abs((a.mv||0)) - Math.abs((b.mv||0)));
    }
    hs = hs.slice(0, 15);
    const parts = hs.map(h => {
      const sym = h.symbol;
      const up = (h.unreal_pct==null) ? '—' : ((100*Number(h.unreal_pct)).toFixed(2) + '%');
      const mv = money(h.mv || 0);
      const tag = (Number(h.unreal || 0) >= 0) ? 'WIN' : 'LOSS';
      return `${sym} ${tag} ${up} (${mv})`;
    });
    return 'Held (' + holdMode + ' 15): ' + parts.join('<br>');
  });

  const traces = [
    {
      x, y: yN,
      type:'scatter', mode:'lines', name:'Portfolio',
      line:{color:'#16a34a', width:2},
      text: holdText,
      hovertemplate:
        '%{x}'
        + '<br>Norm: %{y:.2f}'
        + '<br>Equity: $%{customdata[0]:,.2f}'
        + '<br>Cash: $%{customdata[1]:,.2f}'
        + '<br>Unrealized: $%{customdata[2]:,.2f}'
        + '<br>%{text}'
        + '<extra></extra>',
      customdata: y.map((v,i)=>[v, cash[i], unreal[i]]),
    }
  ];

  if (bm && bm.SP500 && bm.SP500.length) {
    traces.push({
      x: bm.SP500.map(p=>p.date),
      y: bm.SP500.map(p=>p.norm),
      type:'scatter', mode:'lines', name:'S&P 500',
      line:{color:'#111827', width:1.5},
      hovertemplate:'%{x}<br>%{y:.2f}<extra></extra>'
    });
  }

  // SPY comparison removed per user preference

  // Portfolio RSI
  const rsi = computeRSI(y, 14);

  ec.innerHTML = '<div id="btPlot" style="height:520px;"></div>';

  // Regime change markers (from curve.regime)
  const regime = curve.map(p => p.regime || {});
  const changes = [];
  for (let i=1;i<regime.length;i++) {
    const a = regime[i-1], b = regime[i];
    const eqA = a.equity_risk_on, eqB = b.equity_risk_on;
    const crA = a.crypto_risk_on, crB = b.crypto_risk_on;
    if (eqA !== undefined && eqB !== undefined && eqA !== eqB) changes.push({date:x[i], kind:'equity', to:eqB});
    if (crA !== undefined && crB !== undefined && crA !== crB) changes.push({date:x[i], kind:'crypto', to:crB});
  }

  const shapes = [
    {type:'line', xref:'paper', x0:0, x1:1, yref:'y2', y0:30, y1:30, line:{color:'#9ca3af', width:1, dash:'dot'}},
    {type:'line', xref:'paper', x0:0, x1:1, yref:'y2', y0:70, y1:70, line:{color:'#9ca3af', width:1, dash:'dot'}},
  ];

  for (const c of changes.slice(0, 200)) {
    shapes.push({
      type:'line', xref:'x', x0:c.date, x1:c.date, yref:'paper', y0:0, y1:1,
      line:{color: c.kind==='equity' ? '#111827' : '#2563eb', width:1, dash:'dot'}
    });
  }

  const tracesAll = [...traces,
    {
      x, y: rsi,
      xaxis: 'x2', yaxis: 'y2',
      type:'scatter', mode:'lines', name:'Portfolio RSI(14)',
      line:{color:'#7c3aed', width:1.5},
      hovertemplate:'%{x}<br>RSI: %{y:.2f}<extra></extra>'
    }
  ];

  Plotly.newPlot('btPlot', tracesAll, {
    margin:{l:55,r:20,t:10,b:40},
    hovermode:'x unified',
    legend:{orientation:'h'},
    grid:{rows:2, columns:1, pattern:'independent', roworder:'top to bottom'},
    xaxis:{title:'Date', rangeslider:{visible:true}},
    yaxis:{title:'Normalized (100 = start)'},
    xaxis2:{title:'Date', matches:'x', showticklabels:false},
    yaxis2:{title:'RSI', range:[0,100]},
    shapes: shapes,
  }, {displaylogo:false, responsive:true});

  // Open positions table
  const op = document.getElementById('btOpenPos');
  if (op) {
    op.innerHTML = '';
    const openp = res.open_positions || [];
    for (const p of openp.slice(0, 200)) {
      const tr = document.createElement('tr');
      const pnl = Number(p.unrealized_pnl || 0);
      if (pnl > 0) tr.className = 'good';
      if (pnl < 0) tr.className = 'exit';
      const ac = (p.avg_cost!=null) ? ('$' + Number(p.avg_cost).toFixed(2)) : '—';
      const lc = (p.last_close!=null) ? ('$' + Number(p.last_close).toFixed(2)) : '—';
      const pp = (p.unrealized_pnl_pct!=null) ? pct(p.unrealized_pnl_pct) : '—';
      tr.innerHTML = `<td>${p.symbol}</td><td>${Number(p.qty||0).toFixed(4)}</td><td>${ac}</td><td>${lc}</td><td>${money(p.market_value||0)}</td><td>${money(pnl)}</td><td>${pp}</td>`;
      op.appendChild(tr);
    }
    if (op.children.length === 0) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td colspan="7" class="muted">(none)</td>`;
      op.appendChild(tr);
    }
  }

  // P/L by symbol (realized)
  const symTb = document.getElementById('btSymPnl');
  const symSortHdr = document.getElementById('btSymPnlSort');
  if (symTb) {
    const trades = res.trades || [];
    const excluded = new Set(res.excluded_symbols || []);

    // unrealized at end by symbol
    const unrl = new Map();
    for (const p of (res.open_positions || [])) {
      const sym = String(p.symbol||'').trim();
      if (!sym) continue;
      unrl.set(sym, Number(p.unrealized_pnl || 0));
    }

    const agg = new Map();
    for (const t of trades) {
      const sym = String(t.symbol || '').trim();
      if (!sym) continue;
      const pnl = Number(t.pnl || 0);
      const cur = agg.get(sym) || {symbol:sym, realized:0, unreal:0, total:0, n:0};
      cur.realized += pnl;
      cur.n += 1;
      agg.set(sym, cur);
    }

    // ensure open positions appear even if no realized trades
    for (const [sym, upnl] of unrl.entries()) {
      const cur = agg.get(sym) || {symbol:sym, realized:0, unreal:0, total:0, n:0};
      cur.unreal = upnl;
      agg.set(sym, cur);
    }

    for (const cur of agg.values()) {
      cur.unreal = (cur.unreal || 0) + Number(unrl.get(cur.symbol) || 0);
      cur.total = Number(cur.realized || 0) + Number(cur.unreal || 0);
    }

    if (symSortHdr && !symSortHdr.dataset.dir) {
      symSortHdr.dataset.dir = '-1';
      symSortHdr.addEventListener('click', ()=>{
        symSortHdr.dataset.dir = (symSortHdr.dataset.dir === '-1') ? '1' : '-1';
        if (window.__lastBacktestRes) renderBacktest(window.__lastBacktestRes);
      });
    }
    const dir = symSortHdr ? Number(symSortHdr.dataset.dir || '-1') : -1;
    if (symSortHdr) symSortHdr.textContent = `Total ${dir === -1 ? '▾' : '▴'}`;

    const rows = Array.from(agg.values());
    rows.sort((a,b)=> dir * (a.total - b.total));

    symTb.innerHTML = '';
    for (const r of rows.slice(0, 2000)) {
      const tr = document.createElement('tr');
      if (r.total > 0) tr.className = 'good';
      if (r.total < 0) tr.className = 'exit';
      tr.style.cursor = 'pointer';
      const symLabel = excluded.has(r.symbol) ? (r.symbol + ' (excluded)') : r.symbol;
      tr.innerHTML = `<td>${symLabel}</td><td>${r.n}</td><td>${money(r.realized)}</td><td>${money(r.unreal)}</td><td>${money(r.total)}</td>`;

      tr.addEventListener('click', async ()=>{
        const detail = document.getElementById('btSymDetail');
        if (detail) detail.textContent = 'loading ' + r.symbol + '…';
        try {
          const jobId = (window.__lastViewedJobId || null);
          const url = '/api/backtest/symbol?job_id=' + encodeURIComponent(jobId) + '&symbol=' + encodeURIComponent(r.symbol);
          const data = await getJSON(url);
          if (!data.ok) throw new Error(data.error || 'failed');

          const x = data.series.map(p=>p.date);
          const y = data.series.map(p=>p.close);
          const x2 = data.spy.map(p=>p.date);
          const y2 = data.spy.map(p=>p.close);

          const buys = (data.markers||[]).filter(m=>m.type==='buy');
          const sells = (data.markers||[]).filter(m=>m.type==='sell');

          const buyX = buys.map(m=>m.date);
          const buyY = buys.map(m=> (m.price!=null ? Number(m.price) : null));
          const sellX = sells.map(m=>m.date);
          const sellY = sells.map(m=> (m.price!=null ? Number(m.price) : null));

          if (detail) {
            const extra = excluded.has(r.symbol) ? ' • EXCLUDED' : '';
            const evs = (data.events || []);
            let evTable = '';
            if (evs.length) {
              const rows = evs.slice().sort((a,b)=> String(a.date||'').localeCompare(String(b.date||'')));
              evTable = '<div class="tableWrap" style="margin-top:10px; max-height:260px;">'
                + '<table><thead><tr><th>Date</th><th>Type</th><th>Qty</th><th>Price</th><th>Notional</th><th>P/L</th><th>Reason</th></tr></thead><tbody>'
                + rows.map(e=>{
                    const qty = (e.qty!=null) ? Number(e.qty).toFixed(6) : '—';
                    const px = (e.price!=null) ? ('$' + Number(e.price).toFixed(6)) : '—';
                    const notional = (e.notional!=null) ? money(e.notional) : '—';
                    const pnl = (e.pnl!=null) ? money(e.pnl) : '—';
                    return `<tr class="${(Number(e.pnl||0)>0)?'good':((Number(e.pnl||0)<0)?'exit':'')}"><td>${e.date||''}</td><td>${String(e.type||'').toUpperCase()}</td><td>${qty}</td><td>${px}</td><td>${notional}</td><td>${pnl}</td><td>${e.reason||''}</td></tr>`;
                }).join('')
                + '</tbody></table></div>';
            } else {
              evTable = '<div class="muted" style="margin-top:10px;">(no events recorded for this job — run a new backtest)</div>';
            }

            detail.innerHTML = `<div style="margin-bottom:6px;"><b>${data.symbol}</b> (${data.start}→${data.end})${extra}</div>`
              + `<div class="muted" style="margin-bottom:6px;">Realized ${money(r.realized)} • Unrealized(end) ${money(r.unreal)} • Total ${money(r.total)}</div>`
              + `<div id="btSymPlot" style="height:360px;"></div>`
              + `<div style="margin-top:10px; font-weight:700;">Trade events</div>`
              + `<div class="muted" style="margin-top:2px;">All buys/sells recorded by the backtest engine (includes adds/trims). Times are per-day (daily bars).</div>`
              + evTable;

            const traces = [
              {x, y, type:'scatter', mode:'lines', name:data.symbol, line:{color:'#111827'}, hovertemplate:'%{x}<br>$%{y:,.2f}<extra></extra>'},
              {x:x2, y:y2, type:'scatter', mode:'lines', name:'SPY', line:{color:'#2563eb', dash:'dot'}, hovertemplate:'%{x}<br>$%{y:,.2f}<extra></extra>'},
              {x:buyX, y:buyY, type:'scatter', mode:'markers', name:'Buys', marker:{color:'#16a34a', size:10, symbol:'triangle-up'},
                customdata: buys.map(m=>[m.qty, m.notional, m.reason]),
                hovertemplate:'%{x}<br>BUY<br>$%{y:,.6f}<br>qty %{customdata[0]:,.6f}<br>notional $%{customdata[1]:,.2f}<br>%{customdata[2]}<extra></extra>'},
              {x:sellX, y:sellY, type:'scatter', mode:'markers', name:'Sells', marker:{color:'#dc2626', size:10, symbol:'triangle-down'},
                customdata: sells.map(m=>[m.qty, m.notional, m.reason, m.pnl]),
                hovertemplate:'%{x}<br>SELL<br>$%{y:,.6f}<br>qty %{customdata[0]:,.6f}<br>notional $%{customdata[1]:,.2f}<br>pnl $%{customdata[3]:,.2f}<br>%{customdata[2]}<extra></extra>'},
            ];

            Plotly.newPlot('btSymPlot', traces, {
              margin:{l:50,r:20,t:10,b:40},
              hovermode:'x unified',
              xaxis:{title:'Date', rangeslider:{visible:true}},
              yaxis:{title:'Price'},
              legend:{orientation:'h'}
            }, {displaylogo:false, responsive:true});
          }
        } catch (e) {
          const detail = document.getElementById('btSymDetail');
          if (detail) detail.textContent = 'error loading symbol chart: ' + (e?.message || e);
        }
      });

      symTb.appendChild(tr);
    }

    if (symTb.children.length === 0) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td colspan="5" class="muted">(no trades yet)</td>`;
      symTb.appendChild(tr);
    }
  }

  // Daily ledger (curve + events grouped by date)
  const led = document.getElementById('btLedger');
  if (led) {
    led.innerHTML = '';
    const curve = res.equity_curve || [];
    const events = res.events || [];
    const byDate = new Map();
    for (const e of events) {
      const d = String(e.date||'');
      if (!d) continue;
      const arr = byDate.get(d) || [];
      arr.push(e);
      byDate.set(d, arr);
    }

    const lqRaw = (document.getElementById('btLedgerSearch')?.value || '').trim().toUpperCase();
    const lNeedles = lqRaw ? lqRaw.split(/[\s,]+/).filter(Boolean) : [];

    // build rows
    for (let i=0;i<curve.length;i++) {
      const day = curve[i];
      const date = day.date;
      const prev = (i>0) ? curve[i-1] : null;
      const cashEnd = Number(day.cash||0);
      const eqEnd = Number(day.equity||0);
      const cashStart = prev ? Number(prev.cash||0) : cashEnd;
      const eqStart = prev ? Number(prev.equity||0) : eqEnd;
      const invStart = eqStart - cashStart;
      const invEnd = eqEnd - cashEnd;

      const evs = byDate.get(date) || [];
      if (lNeedles.length) {
        const daySyms = new Set(evs.map(e => String(e.symbol||'').toUpperCase()));
        const hit = lNeedles.some(n => {
          for (const s of daySyms) {
            if (s.includes(n)) return true;
          }
          return false;
        });
        if (!hit) continue;
      }
      let buys=0, sells=0;
      for (const e of evs) {
        const n = Number(e.notional||0);
        if (e.type==='buy') buys += n;
        if (e.type==='sell') sells += n;
      }
      const net = sells - buys;

      const tr = document.createElement('tr');
      tr.style.cursor = 'pointer';
      tr.innerHTML = `<td style="width:18px;">▸</td>`
        + `<td style="font-family: ui-monospace, monospace; font-size: 11px;">${date}</td>`
        + `<td>${money(cashStart)}</td>`
        + `<td>${money(cashEnd)}</td>`
        + `<td>${money(eqStart)}</td>`
        + `<td>${money(eqEnd)}</td>`
        + `<td>${money(invStart)}</td>`
        + `<td>${money(invEnd)}</td>`
        + `<td>${money(buys)}</td>`
        + `<td>${money(sells)}</td>`
        + `<td>${money(net)}</td>`
        + `<td>${evs.length}</td>`;

      const detail = document.createElement('tr');
      detail.style.display = 'none';
      const rowsHtml = evs.length ? evs.slice().sort((a,b)=>String(a.type||'').localeCompare(String(b.type||''))).map(e=>{
        const t = String(e.type||'').toLowerCase();
        let expPxNum = null;
        if (e.expected_price!=null) expPxNum = Number(e.expected_price);
        if ((expPxNum==null || !Number.isFinite(expPxNum)) && e.limit_px!=null) expPxNum = Number(e.limit_px);
        if ((expPxNum==null || !Number.isFinite(expPxNum)) && String(e.reason||'')==='limit_fill' && e.price!=null) expPxNum = Number(e.price);

        let qtyNum = (e.qty!=null) ? Number(e.qty) : null;
        if ((qtyNum==null || !Number.isFinite(qtyNum)) && e.notional!=null && expPxNum!=null && expPxNum>0) {
          qtyNum = Number(e.notional) / expPxNum;
        }

        const qty = (qtyNum!=null && Number.isFinite(qtyNum)) ? qtyNum.toFixed(6) : '—';
        const px = (e.price!=null) ? ('$' + Number(e.price).toFixed(6)) : '—';
        const expPx = (expPxNum!=null && Number.isFinite(expPxNum)) ? ('$' + expPxNum.toFixed(6)) : '—';
        const notional = (e.notional!=null) ? money(e.notional) : '—';
        const pnl = (e.pnl!=null) ? money(e.pnl) : '—';
        return `<tr><td>${String(e.type||'').toUpperCase()}</td><td>${e.symbol||''}</td><td>${qty}</td><td>${expPx}</td><td>${px}</td><td>${notional}</td><td>${pnl}</td><td>${e.reason||''}</td></tr>`;
      }).join('') : `<tr><td colspan="8" class="muted">(no buys/sells)</td></tr>`;

      detail.innerHTML = `<td colspan="12">
        <div class="tableWrap" style="max-height:220px; margin:8px 0;">
          <table>
            <thead><tr><th>Type</th><th>Symbol</th><th>Qty</th><th>Expected Px</th><th>Fill Px</th><th>Notional</th><th>P/L</th><th>Reason</th></tr></thead>
            <tbody>${rowsHtml}</tbody>
          </table>
        </div>
      </td>`;

      tr.addEventListener('click', ()=>{
        const open = detail.style.display !== 'none';
        detail.style.display = open ? 'none' : '';
        tr.querySelector('td').textContent = open ? '▸' : '▾';
      });

      led.appendChild(tr);
      led.appendChild(detail);
    }

    if (led.children.length === 0) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td colspan="12" class="muted">(no data)</td>`;
      led.appendChild(tr);
    }
  }

  // Trades table
  const tb = document.getElementById('btTrades');
  if (tb) {
    tb.innerHTML = '';
    const trades = res.trades || [];
    trades.sort((a,b) => String(b.exit_date||'').localeCompare(String(a.exit_date||'')));
    const qRaw = (document.getElementById('btTradeSearch')?.value || '').trim().toUpperCase();
    const needles = qRaw ? qRaw.split(/[\s,]+/).filter(Boolean) : [];
    const filtered = needles.length ? trades.filter(t => needles.some(n => String(t.symbol||'').toUpperCase().includes(n))) : trades;
    for (const t of filtered.slice(0, 500)) {
      const tr = document.createElement('tr');
      const pnl = Number(t.pnl || 0);
      if (pnl > 0) tr.className = 'good';
      if (pnl < 0) tr.className = 'exit';
      const ep = (t.entry_price!=null) ? ('$' + Number(t.entry_price).toFixed(2)) : '—';
      const xp = (t.exit_price!=null) ? ('$' + Number(t.exit_price).toFixed(2)) : '—';
      const pp = (t.pnl_pct!=null) ? pct(t.pnl_pct) : '—';
      tr.innerHTML = `<td>${t.symbol}</td><td>${t.entry_date||'—'}</td><td>${t.exit_date||'—'}</td><td>${Number(t.qty||0).toFixed(4)}</td><td>${ep}</td><td>${xp}</td><td>${money(pnl)}</td><td>${pp}</td><td>${t.reason||''}</td>`;
      tb.appendChild(tr);
    }
    if (tb.children.length === 0) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td colspan="9" class="muted">(no realized trades yet)</td>`;
      tb.appendChild(tr);
    }
  }
}

function toast(kind, title, msg) {
  const el = document.createElement('div');
  el.className = 'toast ' + (kind || 'ok');
  el.innerHTML = `<div class="toastTitle">${title||''}</div><div class="toastMsg muted">${msg||''}</div>`;
  document.body.appendChild(el);
  setTimeout(()=>{ try { el.remove(); } catch(e){} }, 3600);
}

function applyTheme(t) {
  document.documentElement.dataset.theme = t || 'classic';
  try { localStorage.setItem('ui_theme', document.documentElement.dataset.theme); } catch(e) {}
}

function applyDensity(d) {
  const v = d || 'comfortable';
  document.documentElement.dataset.density = v;
  document.body.classList.toggle('density-compact', v === 'compact');
  try { localStorage.setItem('ui_density', v); } catch(e) {}
}

function initThemePicker() {
  const sel = document.getElementById('themeSel');
  const dens = document.getElementById('densitySel');

  const savedTheme = (()=>{ try { return localStorage.getItem('ui_theme'); } catch(e) { return null; } })();
  applyTheme(savedTheme || document.documentElement.dataset.theme || 'classic');

  const savedDens = (()=>{ try { return localStorage.getItem('ui_density'); } catch(e) { return null; } })();
  applyDensity(savedDens || document.documentElement.dataset.density || 'comfortable');

  if (sel) {
    sel.value = document.documentElement.dataset.theme || 'classic';
    sel.addEventListener('change', ()=> applyTheme(sel.value));
  }
  if (dens) {
    dens.value = document.documentElement.dataset.density || 'comfortable';
    dens.addEventListener('change', ()=> applyDensity(dens.value));
  }
}

async function main() {
  initThemePicker();

  const [health, cfg, acct, st, exposure, artifacts, curve, openOrders, recentFills, orderSummary, btJobs, strategies, btPresets, latestAction, scheduleStatus, cronStatus] = await Promise.all([
    getJSON('/api/health'),
    getJSON('/api/config'),
    getJSON('/api/account'),
    getJSON('/api/state'),
    getJSON('/api/exposure'),
    getJSON('/api/artifacts'),
    getJSON('/api/equity-curve?limit=500'),
    getJSON('/api/open-orders'),
    getJSON('/api/recent-fills?limit=200'),
    getJSON('/api/order-summary'),
    getJSON('/api/backtest/jobs?limit=20'),
    getJSON('/api/strategies'),
    getJSON('/api/backtest/presets'),
    getJSON('/api/actions/latest?kind=rebalance').catch(()=>({state:'missing'})),
    getJSON('/api/actions/schedule-status').catch(()=>({risk_daily_enabled:false})),
    getJSON('/api/scheduler/cron-status').catch(()=>({enabled:false, rebalance:[], risk:[]}))
  ]);

  const frozen = artifacts.last_account?.payload?.frozen;
  const dd = artifacts.last_account?.payload?.drawdown;
  const status = frozen ? 'FROZEN' : 'OK';
  document.getElementById('subtitle').textContent = `paper=${acct.paper} • status=${status}${(dd!==undefined && dd!==null) ? (' • dd=' + pct(dd)) : ''} • updated ${health.ts}`;

  const accountEl = document.getElementById('account');
  accountEl.innerHTML = '';
  accountEl.className = 'accountBlocks';

  const mkBlock = (title, rows) => {
    const b = document.createElement('div');
    b.className = 'subcard accountBlock';
    b.style.padding = '10px';
    const h = document.createElement('div');
    h.style.fontWeight = '700';
    h.style.marginBottom = '6px';
    h.textContent = title;
    b.appendChild(h);
    const g = document.createElement('div');
    g.className = 'kvs accountKvs';
    for (const [k,v] of rows) kv(g, k, v);
    b.appendChild(g);
    accountEl.appendChild(b);
  };

  mkBlock('Identity', [
    ['Account', acct.account_number],
    ['Status', (acct.status || '—') + (acct.paper ? ' (paper)' : '')],
    ['Currency', acct.currency || 'USD'],
    ['Crypto status', acct.crypto_status || '—'],
  ]);

  mkBlock('Cash & Equity (Today)', [
    ['BOD equity', money(acct.bod_equity)],
    ['Current equity', money(acct.equity)],
    ['Day Δ equity', (acct.day_change_equity==null ? '—' : (money(acct.day_change_equity) + ' (' + pct(acct.day_change_equity_pct) + ')'))],
    ['BOD cash', money(acct.bod_cash)],
    ['Current cash', money(acct.cash)],
    ['Day Δ cash', acct.day_change_cash==null ? '—' : money(acct.day_change_cash)],
  ]);

  mkBlock('Risk / Restrictions', [
    ['PDT', String(Boolean(acct.pattern_day_trader))],
    ['Trading blocked', String(Boolean(acct.trading_blocked))],
    ['Transfers blocked', String(Boolean(acct.transfers_blocked))],
    ['Account blocked', String(Boolean(acct.account_blocked))],
    ['Shorting enabled', String(Boolean(acct.shorting_enabled))],
  ]);

  mkBlock('Buying Power & Margin', [
    ['Portfolio value', money(acct.portfolio_value)],
    ['Buying power', money(acct.buying_power)],
    ['Reg-T buying power', money(acct.regt_buying_power)],
    ['Day-trading BP', money(acct.daytrading_buying_power)],
    ['Initial margin', money(acct.initial_margin)],
    ['Maintenance margin', money(acct.maintenance_margin)],
    ['SMA', money(acct.sma)],
  ]);

  const stateEl = document.getElementById('state');
  stateEl.innerHTML = '';
  kv(stateEl, 'Peak equity', money(st.peak_equity));
  kv(stateEl, 'Mode', cfg.mode);
  kv(stateEl, 'Dry run (config)', String(cfg.dry_run));
  const cronReb = Boolean(cronStatus?.rebalance_enabled);
  const cronRisk = Boolean(cronStatus?.risk_enabled);

  // If cron is enabled, treat queue flags as true and show cron schedule.
  const queued = cronReb || Boolean(scheduleStatus?.rebalance_weekly_enabled);
  kv(stateEl, 'Run-at-time queued', queued ? 'YES' : 'NO');
  if (cronReb && cronStatus?.rebalance_schedule) {
    kv(stateEl, 'Rebalance schedule', `${cronStatus.rebalance_schedule.day} ${cronStatus.rebalance_schedule.hhmm} (cron)`);
  } else if (queued) {
    kv(stateEl, 'Rebalance next run', scheduleStatus?.rebalance_next_run || '—');
    kv(stateEl, 'Rebalance scheduler', (scheduleStatus?.rebalance_last_state || 'running') + (scheduleStatus?.rebalance_last_error ? (' • ' + scheduleStatus.rebalance_last_error) : ''));
  } else {
    kv(stateEl, 'Run-at-time', 'Click "Run at configured time" to queue');
  }

  const riskQueued = cronRisk || Boolean(scheduleStatus?.risk_daily_enabled);
  kv(stateEl, 'Daily risk-check queued', riskQueued ? 'YES' : 'NO');
  if (cronRisk && cronStatus?.risk_schedule) {
    kv(stateEl, 'Risk schedule', `${cronStatus.risk_schedule.hhmm} daily (cron)`);
  } else if (scheduleStatus?.risk_daily_enabled) {
    kv(stateEl, 'Risk next run', scheduleStatus?.risk_next_run || '—');
    kv(stateEl, 'Risk scheduler', (scheduleStatus?.risk_last_state || 'running') + (scheduleStatus?.risk_last_error ? (' • ' + scheduleStatus.risk_last_error) : ''));
  }
  kv(stateEl, 'Cron scheduler enabled', cronStatus?.enabled ? 'YES' : 'NO');

  // Strategy dropdown (live)
  const stratSel = document.getElementById('strategySelect');
  if (stratSel && strategies) {
    if (!stratSel.dataset.loaded) {
      stratSel.innerHTML = '';
      for (const s of strategies) {
        const opt = document.createElement('option');
        opt.value = s.id;
        opt.textContent = s.name;
        stratSel.appendChild(opt);
      }
      stratSel.dataset.loaded = '1';
    }
    stratSel.value = cfg.strategy_id || 'baseline_trendvol';
  }

  // Strategy dropdown (backtest) - do NOT overwrite user selection on refresh
  const btStrat = document.getElementById('btStrategy');
  if (btStrat && strategies) {
    if (!btStrat.dataset.loaded) {
      btStrat.innerHTML = '';
      for (const s of strategies) {
        const opt = document.createElement('option');
        opt.value = s.id;
        opt.textContent = (s.source === 'user') ? (s.name + ' (user)') : s.name;
        btStrat.appendChild(opt);
      }
      btStrat.dataset.loaded = '1';
      btStrat.value = cfg.strategy_id || 'baseline_trendvol';
    }
  }

  // Stop loss dropdown
  const slSel = document.getElementById('stopLossSelect');
  if (slSel) {
    const v = cfg.risk?.per_asset_stop_loss_pct;
    slSel.value = (v===null || v===undefined) ? '' : String(v);
  }

  // Guardrail inputs
  const setGuard = (id, v) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.value = (v===null || v===undefined) ? 'none' : String(v);
  };
  setGuard('maxOrdersInput', cfg.execution?.max_orders_per_run);
  setGuard('maxSingleInput', cfg.execution?.max_single_order_notional_usd);
  setGuard('maxTotalInput', cfg.execution?.max_total_notional_usd);
  const ulo = document.getElementById('useLimitOrdersSelect');
  if (ulo) ulo.value = String(Boolean(cfg.execution?.use_limit_orders));
  const loi = document.getElementById('limitOffsetInput');
  if (loi) loi.value = String(cfg.execution?.limit_offset_bps ?? 10);
  const ehe = document.getElementById('extendedHoursSelect');
  if (ehe) ehe.value = String(Boolean(cfg.execution?.extended_hours));
  const fbe = document.getElementById('fallbackEnableSelect');
  if (fbe) fbe.value = String(Boolean(cfg.execution?.fallback_to_market_at_open));
  const est = document.getElementById('extendedStartTimeInput');
  if (est) est.value = String(cfg.execution?.extended_hours_start_time_local ?? '06:00');
  const fbt = document.getElementById('fallbackTimeInput');
  if (fbt) fbt.value = String(cfg.execution?.fallback_time_local ?? '06:30');
  const wrd = document.getElementById('weeklyRebalanceDaySelect');
  if (wrd) wrd.value = String(cfg.scheduling?.weekly_rebalance_day || 'MON');

  // Config editor
  const editor = document.getElementById('configEditor');
  if (editor && (!editor.value || editor.dataset.loaded !== '1')) {
    editor.value = JSON.stringify(cfg, null, 2);
    editor.dataset.loaded = '1';
  }

  // Equity curve chart (interactive)
  const ec = document.getElementById('equityChart');
  if (!curve || curve.length < 2) {
    ec.textContent = '(need at least 2 points; run risk-check a few times)';
  } else {
    const x = curve.map(p => p.ts);
    const y = curve.map(p => Number(p.equity));
    ec.innerHTML = '<div id="equityPlot" style="height:320px;"></div>';
    Plotly.newPlot('equityPlot', [
      {x, y, type:'scatter', mode:'lines', name:'Portfolio', line:{color:'#2563eb'}, hovertemplate:'%{x}<br>$%{y:,.2f}<extra></extra>'}
    ], {
      margin:{l:50,r:20,t:10,b:40},
      xaxis:{title:'Time'},
      yaxis:{title:'Equity'}
    }, {displaylogo:false, responsive:true});
  }

  const tb = document.getElementById('exposure');
  tb.innerHTML = '';
  for (const p of (exposure || [])) {
    const pendingBuyN = (p.pending_buy_notional && p.pending_buy_notional !== 0) ? money(p.pending_buy_notional) : '—';
    const pendingSellN = (p.pending_sell_notional && p.pending_sell_notional !== 0) ? money(p.pending_sell_notional) : '—';
    const pendingBuyQ = (p.pending_buy_qty && p.pending_buy_qty !== 0) ? p.pending_buy_qty : '—';
    const pendingSellQ = (p.pending_sell_qty && p.pending_sell_qty !== 0) ? p.pending_sell_qty : '—';
    const estPrice = (p.est_price!==null && p.est_price!==undefined) ? ('$' + Number(p.est_price).toFixed(2) + ' (close)') : '—';
    const estQty = (p.est_pending_buy_qty!==null && p.est_pending_buy_qty!==undefined) ? Number(p.est_pending_buy_qty).toFixed(4) : '—';

    const hasOrders = (p.open_orders && p.open_orders.length);
    const caret = hasOrders ? '▸' : '';

    const tr = document.createElement('tr');
    tr.style.cursor = hasOrders ? 'pointer' : 'default';
    tr.innerHTML = `<td class="muted">${caret}</td><td>${p.symbol}</td><td>${p.held_qty}</td><td>${money(p.market_value)}</td><td>${pendingBuyQ}</td><td>${pendingBuyN}</td><td>${estPrice}</td><td>${estQty}</td><td>${pendingSellQ}</td><td>${pendingSellN}</td><td>${money(p.avg_entry_price)}</td><td>${money(p.unrealized_pl)}</td><td>${pct(p.unrealized_plpc)}</td>`;
    tb.appendChild(tr);

    if (hasOrders) {
      const detail = document.createElement('tr');
      detail.style.display = 'none';
      const ordersHtml = p.open_orders.map(o => {
        const lim = (o.limit_price!==null && o.limit_price!==undefined) ? ('$' + Number(o.limit_price).toFixed(2)) : '—';
        const stp = (o.stop_price!==null && o.stop_price!==undefined) ? ('$' + Number(o.stop_price).toFixed(2)) : '—';
        return `<tr>
          <td style="font-family: ui-monospace, monospace; font-size: 11px;">${o.id}</td>
          <td>${o.side}</td><td>${o.status}</td><td>${o.type||''}</td>
          <td>${o.qty||'—'}</td><td>${o.notional ? money(o.notional) : '—'}</td>
          <td>${lim}</td><td>${stp}</td><td>${o.created_at||''}</td>
        </tr>`;
      }).join('');

      detail.innerHTML = `<td colspan="13">
        <div style="padding:8px 0;">
          <table>
            <thead>
              <tr><th>Order Id</th><th>Side</th><th>Status</th><th>Type</th><th>Qty</th><th>Notional</th><th>Limit</th><th>Stop</th><th>Created</th></tr>
            </thead>
            <tbody>${ordersHtml}</tbody>
          </table>
        </div>
      </td>`;
      tb.appendChild(detail);

      tr.addEventListener('click', () => {
        const open = detail.style.display !== 'none';
        detail.style.display = open ? 'none' : '';
        tr.querySelector('td').textContent = open ? '▸' : '▾';
      });
    }
  }

  // Backtest presets
  const presetSel = document.getElementById('btPreset');
  const presetStatus = document.getElementById('btPresetStatus');
  const presets = (btPresets && btPresets.presets) ? btPresets.presets : [];
  if (presetSel) {
    if (!presetSel.dataset.loaded) {
      presetSel.innerHTML = '';
      for (const p of presets) {
        const opt = document.createElement('option');
        opt.value = p.name;
        opt.textContent = p.name;
        presetSel.appendChild(opt);
      }
      presetSel.dataset.loaded = '1';
    }
  }

  function collectBTParams() {
    const stopLoss = (document.getElementById('btStopLoss')?.value || '').trim();
    const per_asset_stop_loss_pct = stopLoss ? Number(stopLoss) : null;
    const ddCustom = (document.getElementById('btDD')?.value || '').trim();
    const ddPreset = (document.getElementById('btDDPreset')?.value || '').trim();
    const ddStopRaw = ddCustom || ddPreset;
    const portfolio_dd_stop = ddStopRaw ? Number(ddStopRaw) : null;
    const symFloorRaw = (document.getElementById('btSymFloor')?.value || '').trim();
    const symbol_pnl_floor_pct = symFloorRaw ? Number(symFloorRaw) : null;

    return {
      strategy_id: (document.getElementById('btStrategy')?.value || 'baseline_trendvol'),
      execution_time_mode: (document.getElementById('btExecMode')?.value || 'daily'),
      execution_time: (document.getElementById('btExecTime')?.value || 'close'),
      execution_time_local: (document.getElementById('btExecLocal')?.value || '15:55'),
      risk_check_time_local: (document.getElementById('btRiskTime')?.value || '12:30'),
      execution_tz: 'America/Los_Angeles',
      asset_mode: (document.getElementById('btAssets')?.value || 'both'),
      rebalance: (document.getElementById('btRebalance')?.value || 'weekly'),
      rebalance_day: (document.getElementById('btRebalanceDay')?.value || 'MON'),
      rebalance_frequency_equities: (document.getElementById('btEqRebFreq')?.value || 'weekly'),
      rebalance_day_equities: (document.getElementById('btEqRebDay')?.value || 'MON'),
      rebalance_frequency_crypto: (document.getElementById('btCrRebFreq')?.value || 'weekly'),
      rebalance_day_crypto: (document.getElementById('btCrRebDay')?.value || 'MON'),
      risk_check_frequency_equities: (document.getElementById('btEqRiskFreq')?.value || 'daily'),
      risk_check_day_equities: (document.getElementById('btEqRiskDay')?.value || 'MON'),
      risk_check_frequency_crypto: (document.getElementById('btCrRiskFreq')?.value || 'daily'),
      risk_check_day_crypto: (document.getElementById('btCrRiskDay')?.value || 'MON'),
      rebalance_mode: (document.getElementById('btRebalanceMode')?.value || 'target_notional'),
      liquidation_mode: (document.getElementById('btLiquidation')?.value || 'liquidate_non_selected'),
      slippage_bps: Number(document.getElementById('btSlip')?.value || '10'),
      use_limit_orders: String(document.getElementById('btUseLimit')?.value || 'false') === 'true',
      limit_offset_bps: Number(document.getElementById('btLimitOffset')?.value || '10'),
      order_type_equities: (document.getElementById('btEqOrderType')?.value || 'market'),
      order_type_crypto: (document.getElementById('btCrOrderType')?.value || 'market'),
      limit_offset_bps_equities: Number(document.getElementById('btEqLimitOffset')?.value || '10'),
      limit_offset_bps_crypto: Number(document.getElementById('btCrLimitOffset')?.value || '10'),
      limit_fallback_to_market_open: String(document.getElementById('btLimitFallback')?.value || 'false') === 'true',
      limit_fallback_time_local: (document.getElementById('btLimitFallbackTime')?.value || '06:30'),
      per_asset_stop_loss_pct,
      portfolio_dd_stop,
      symbol_pnl_floor_pct,
      symbol_pnl_floor_liquidate: Boolean(document.getElementById('btSymFloorLiquidate')?.checked),
      symbol_pnl_floor_include_unrealized: Boolean(document.getElementById('btSymFloorInclUnreal')?.checked),
    };
  }

  function applyBTParamsToUI(p) {
    if (!p) return;
    const setVal = (id, v) => { const el=document.getElementById(id); if(el && v!==undefined && v!==null) el.value=String(v); };
    setVal('btStrategy', p.strategy_id);
    setVal('btExecMode', p.execution_time_mode);
    setVal('btExecTime', p.execution_time);
    setVal('btExecLocal', p.execution_time_local);
    setVal('btRiskTime', p.risk_check_time_local);
    setVal('btAssets', p.asset_mode);
    setVal('btRebalance', p.rebalance);
    setVal('btRebalanceDay', p.rebalance_day);
    setVal('btEqRebFreq', p.rebalance_frequency_equities);
    setVal('btEqRebDay', p.rebalance_day_equities);
    setVal('btCrRebFreq', p.rebalance_frequency_crypto);
    setVal('btCrRebDay', p.rebalance_day_crypto);
    setVal('btEqRiskFreq', p.risk_check_frequency_equities);
    setVal('btEqRiskDay', p.risk_check_day_equities);
    setVal('btCrRiskFreq', p.risk_check_frequency_crypto);
    setVal('btCrRiskDay', p.risk_check_day_crypto);
    setVal('btRebalanceMode', p.rebalance_mode);
    setVal('btLiquidation', p.liquidation_mode);
    setVal('btSlip', p.slippage_bps);
    setVal('btUseLimit', String(Boolean(p.use_limit_orders)));
    setVal('btLimitOffset', p.limit_offset_bps);
    setVal('btEqOrderType', p.order_type_equities);
    setVal('btCrOrderType', p.order_type_crypto);
    setVal('btEqLimitOffset', p.limit_offset_bps_equities);
    setVal('btCrLimitOffset', p.limit_offset_bps_crypto);
    setVal('btLimitFallback', String(Boolean(p.limit_fallback_to_market_open)));
    setVal('btLimitFallbackTime', p.limit_fallback_time_local);
    setVal('btStopLoss', p.per_asset_stop_loss_pct);
    setVal('btDD', '');
    setVal('btDDPreset', p.portfolio_dd_stop);
    setVal('btSymFloor', p.symbol_pnl_floor_pct);
    const liq = document.getElementById('btSymFloorLiquidate');
    if (liq && p.symbol_pnl_floor_liquidate!==undefined) liq.checked = Boolean(p.symbol_pnl_floor_liquidate);
    const iu = document.getElementById('btSymFloorInclUnreal');
    if (iu && p.symbol_pnl_floor_include_unrealized!==undefined) iu.checked = Boolean(p.symbol_pnl_floor_include_unrealized);
  }

  const btnLoad = document.getElementById('btPresetLoad');
  if (btnLoad && !btnLoad.dataset.wired) {
    btnLoad.dataset.wired = '1';
    btnLoad.addEventListener('click', (e)=>{
      e.preventDefault();
      const name = presetSel?.value;
      const p = presets.find(x=>x.name===name);
      if (!p) return;
      applyBTParamsToUI(p.params || {});
      if (presetStatus) presetStatus.textContent = 'loaded preset ' + name;
    });
  }

  const btnSave = document.getElementById('btPresetSave');
  if (btnSave && !btnSave.dataset.wired) {
    btnSave.dataset.wired = '1';
    btnSave.addEventListener('click', async (e)=>{
      e.preventDefault();
      const name = (document.getElementById('btPresetName')?.value || '').trim();
      if (!name) { if(presetStatus) presetStatus.textContent='enter a preset name'; return; }
      if (presetStatus) presetStatus.textContent = 'saving…';
      try {
        await postJSON('/api/backtest/presets/save', {name, params: collectBTParams()});
        if (presetStatus) presetStatus.textContent = 'saved preset ' + name + ' (refresh page to see in dropdown)';
        toast('ok','Preset saved', name);
      } catch (err) {
        if (presetStatus) presetStatus.textContent = 'save error: ' + (err?.message || err);
        toast('err','Preset save error', String(err?.message || err));
      }
    });
  }

  const btnUpdate = document.getElementById('btPresetUpdate');
  if (btnUpdate && !btnUpdate.dataset.wired) {
    btnUpdate.dataset.wired = '1';
    btnUpdate.addEventListener('click', async (e)=>{
      e.preventDefault();
      const name = presetSel?.value;
      if (!name) { if(presetStatus) presetStatus.textContent='select a preset'; return; }
      if (presetStatus) presetStatus.textContent = 'updating…';
      try {
        await postJSON('/api/backtest/presets/save', {name, params: collectBTParams()});
        if (presetStatus) presetStatus.textContent = 'updated preset ' + name;
        toast('ok','Preset updated', name);
      } catch (err) {
        if (presetStatus) presetStatus.textContent = 'update error: ' + (err?.message || err);
        toast('err','Preset update error', String(err?.message || err));
      }
    });
  }

  const btnApply = document.getElementById('btPresetApply');
  if (btnApply && !btnApply.dataset.wired) {
    btnApply.dataset.wired = '1';
    btnApply.addEventListener('click', async (e)=>{
      e.preventDefault();
      const name = presetSel?.value;
      if (!name) { if(presetStatus) presetStatus.textContent='select a preset'; return; }
      if (presetStatus) presetStatus.textContent = 'applying to config…';
      try {
        const res = await postJSON('/api/backtest/presets/apply-live', {name});
        if (!res.ok) throw new Error(res.error||'failed');
        if (presetStatus) presetStatus.textContent = 'applied preset ' + name + ' to live config';
        toast('ok','Applied to config', name);
        // refresh dashboard/config editor so changes are visible immediately
        await main();
      } catch (err) {
        if (presetStatus) presetStatus.textContent = 'apply error: ' + (err?.message || err);
      }
    });
  }

  // Backtest history
  const jb = document.getElementById('btJobs');
  if (jb) {
    jb.innerHTML = '';
    for (const j of (btJobs || [])) {
      const tr = document.createElement('tr');
      const btn = `<button data-job="${j.job_id}" class="btViewBtn secondary" style="padding:3px 8px;">View</button>`;
      const rm = j.result_metrics || {};
      const rp = j.result_params || {};
      const rRet = (rm.return==null) ? '—' : pct(rm.return);
      const rCagr = (rm.cagr==null) ? '—' : pct(rm.cagr);
      const rDd = (rm.max_drawdown==null) ? '—' : pct(rm.max_drawdown);
      const rSh = (rm.sharpe==null) ? '—' : Number(rm.sharpe).toFixed(2);
      const strat = rp.strategy_id || '—';
      const mode = rp.asset_mode || '—';
      const freq = rp.rebalance || '—';
      const summary = `ret ${rRet} • cagr ${rCagr} • dd ${rDd} • sh ${rSh}`;

      tr.innerHTML = `<td style="font-family: ui-monospace, monospace; font-size: 11px;">${j.job_id}</td>`
        + `<td>${j.state||''}</td>`
        + `<td>${(j.progress||0)}/${(j.total||0)}</td>`
        + `<td style="font-size:12px;">${strat} • ${mode} • ${freq}<div class="muted" style="font-size:11px; margin-top:2px;">${summary}</div></td>`
        + `<td>${(j.error||'').slice(0,80)}</td>`
        + `<td>${btn}</td>`;
      jb.appendChild(tr);
    }

    // wire view buttons
    document.querySelectorAll('.btViewBtn').forEach(el => {
      el.addEventListener('click', async (e) => {
        e.preventDefault();
        const job = el.getAttribute('data-job');
        document.getElementById('btStatus').textContent = 'loading job ' + job + '…';
        try {
          const res = await getJSON('/api/backtest/result?job_id=' + encodeURIComponent(job));
          window.__lastViewedJobId = job;
          await renderBacktest(res);
          document.getElementById('btStatus').textContent = 'viewing ' + job;
        } catch (err) {
          document.getElementById('btStatus').textContent = 'error loading ' + job;
        }
      });
    });
    if (jb.children.length === 0) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td colspan="4" class="muted">(none)</td>`;
      jb.appendChild(tr);
    }
  }

  // Summary
  const os = document.getElementById('orderSummary');
  if (os && orderSummary) {
    os.textContent = `open orders: ${orderSummary.open_count} (notional ~${money(orderSummary.open_notional)}) • fills: ${orderSummary.fills_count}`;
  }

  // Open orders
  const oo = document.getElementById('openOrders');
  oo.innerHTML = '';
  for (const o of (openOrders || [])) {
    const tr = document.createElement('tr');
    const lim = (o.limit_price!==null && o.limit_price!==undefined) ? ('$' + Number(o.limit_price).toFixed(2)) : '—';
    const stp = (o.stop_price!==null && o.stop_price!==undefined) ? ('$' + Number(o.stop_price).toFixed(2)) : '—';
    tr.innerHTML = `<td>${o.symbol}</td><td>${o.side}</td><td>${o.status}</td><td>${o.type||''}</td><td>${o.notional_usd ? money(o.notional_usd) : '—'}</td><td>${o.qty || '—'}</td><td>${lim}</td><td>${stp}</td><td>${o.created_at || ''}</td>`;
    oo.appendChild(tr);
  }

  // Recent fills
  const rf = document.getElementById('recentFills');
  rf.innerHTML = '';
  const placedById = new Map((artifacts.last_placed_orders?.payload?.orders || []).map(o => [String(o.id||''), o]));
  for (const o of (recentFills || [])) {
    const tr = document.createElement('tr');
    const fill = (o.filled_avg_price!==null && o.filled_avg_price!==undefined && o.filled_avg_price !== '') ? Number(o.filled_avg_price) : null;
    const placed = placedById.get(String(o.id||'')) || null;
    const exp = (o.limit_price!==null && o.limit_price!==undefined && o.limit_price !== '')
      ? Number(o.limit_price)
      : ((placed && placed.expected_price!=null) ? Number(placed.expected_price) : null);
    const fillTxt = (fill!=null) ? ('$' + fill.toFixed(4)) : '—';
    const expTxt = (exp!=null) ? ('$' + exp.toFixed(4)) : '—';
    let slipTxt = '—';
    if (fill!=null && exp!=null && exp>0) {
      const bps = (fill - exp) / exp * 10000;
      const side = String(o.side||'').toUpperCase();
      // positive means worse for buys, better for sells
      const signed = (side === 'SELL') ? (-bps) : bps;
      slipTxt = `${signed>=0?'+':''}${signed.toFixed(1)} bps`;
    }
    tr.innerHTML = `<td>${o.symbol}</td><td>${o.side}</td><td>${o.filled_qty || '—'}</td><td>${expTxt}</td><td>${fillTxt}</td><td>${slipTxt}</td><td>${o.filled_at || ''}</td>`;
    rf.appendChild(tr);
  }

  // Last placed orders
  const lp = document.getElementById('lastPlaced');
  lp.innerHTML = '';
  const placed = artifacts.last_placed_orders?.payload?.orders || [];
  for (const o of placed) {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${o.symbol}</td><td>${o.side}</td><td>${money(o.notional_usd)}</td><td style="font-family: ui-monospace, monospace; font-size: 11px;">${o.id}</td>`;
    lp.appendChild(tr);
  }

  // Last run summaries
  const rbSum = document.getElementById('rebalanceSummary');
  const rkSum = document.getElementById('riskSummary');

  if (rbSum) {
    rbSum.innerHTML = '';
    const rb = artifacts.last_rebalance?.payload;
    if (!rb) {
      kv(rbSum, 'Status', '—');
    } else {
      kv(rbSum, 'Frozen', String(rb.frozen));
      kv(rbSum, 'Universe', `eq=${rb.universe?.equities ?? '—'} cr=${rb.universe?.crypto ?? '—'}`);
      kv(rbSum, 'Selected equities', (rb.selected?.equities || []).join(', ') || '—');
      kv(rbSum, 'Selected crypto', (rb.selected?.crypto || []).join(', ') || '—');
      kv(rbSum, 'Planned orders', String((rb.plans || []).length));

      // Entry signals table (selected)
      const entBody = document.getElementById('entrySignals');
      if (entBody) {
        entBody.innerHTML = '';
        const addRow = (sym, v) => {
          const tr = document.createElement('tr');
          const scoreNum = (v?.score!==null && v?.score!==undefined) ? Number(v.score) : null;
          const score = (scoreNum!==null && !Number.isNaN(scoreNum)) ? scoreNum.toFixed(4) : '—';
          const close = (v?.last_close!==null && v?.last_close!==undefined) ? ('$' + Number(v.last_close).toFixed(2)) : '—';
          const maL = (v?.ma_long!==null && v?.ma_long!==undefined) ? ('$' + Number(v.ma_long).toFixed(2)) : '—';
          const vol = (v?.ann_vol!==null && v?.ann_vol!==undefined) ? (Number(v.ann_vol).toFixed(2)) : '—';
          if (scoreNum !== null && scoreNum >= 0.25) tr.className = 'good';
          tr.innerHTML = `<td>${sym}</td><td>${score}</td><td>${close}</td><td>${maL}</td><td>${vol}</td>`;
          entBody.appendChild(tr);
        };

        const eqEnt = rb.entry_signals?.equities || {};
        const crEnt = rb.entry_signals?.crypto || {};
        const entries = [];
        for (const [sym, v] of Object.entries(eqEnt)) entries.push([sym, v]);
        for (const [sym, v] of Object.entries(crEnt)) entries.push([sym, v]);
        entries.sort((a,b) => (Number(b[1]?.score||0) - Number(a[1]?.score||0)));
        for (const [sym,v] of entries) addRow(sym, v);
        if (entBody.children.length === 0) {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td colspan="5" class="muted">(none)</td>`;
          entBody.appendChild(tr);
        }
      }
    }
  }

  if (rkSum) {
    rkSum.innerHTML = '';
    const rk = artifacts.last_risk_check?.payload;
    if (!rk) {
      kv(rkSum, 'Status', '—');
    } else {
      kv(rkSum, 'Equity', money(rk.equity));
      kv(rkSum, 'Peak equity', money(rk.peak_equity));
      kv(rkSum, 'Drawdown', pct(rk.drawdown));
      kv(rkSum, 'Frozen', String(rk.frozen));
      const exits = (rk.exit_signals || []);
      kv(rkSum, 'Exit signals', String(exits.length));

      const exBody = document.getElementById('exitSignals');
      if (exBody) {
        exBody.innerHTML = '';
        for (const e of exits) {
          const tr = document.createElement('tr');
          tr.className = 'exit';
          const close = (e.last_close!==null && e.last_close!==undefined) ? ('$' + Number(e.last_close).toFixed(2)) : '—';
          const maL = (e.ma_long!==null && e.ma_long!==undefined) ? ('$' + Number(e.ma_long).toFixed(2)) : '—';
          tr.innerHTML = `<td>${e.symbol}</td><td>${e.asset_class}</td><td>${e.reason}</td><td>${close}</td><td>${maL}</td>`;
          exBody.appendChild(tr);
        }
        if (exBody.children.length === 0) {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td colspan="5" class="muted">(none)</td>`;
          exBody.appendChild(tr);
        }
      }
    }
  }

  document.getElementById('rebalance').textContent = artifacts.last_rebalance ? JSON.stringify(artifacts.last_rebalance, null, 2) : '(none yet)';
  document.getElementById('risk').textContent = artifacts.last_risk_check ? JSON.stringify(artifacts.last_risk_check, null, 2) : '(none yet)';
}

setDefaultBacktestDates();
refreshIterationReportsList().catch(()=>{});

main().catch(err => {
  document.getElementById('subtitle').textContent = 'error: ' + err;
});

// Auto-refresh
async function saveConfig() {
  const status = document.getElementById('saveStatus');
  try {
    const token = document.getElementById('token')?.value || '';
    const body = JSON.parse(document.getElementById('configEditor').value);
    // sync dropdowns into config
    const strat = document.getElementById('strategySelect')?.value;
    if (strat) body.strategy_id = strat;
    const sl = document.getElementById('stopLossSelect')?.value;
    body.risk = body.risk || {};
    body.risk.per_asset_stop_loss_pct = sl ? Number(sl) : null;

    const parseMaybeNone = (v, isInt=false) => {
      const s = String(v ?? '').trim().toLowerCase();
      if (!s || s === 'none' || s === 'null' || s === 'unlimited' || s === '∞') return null;
      const n = isInt ? parseInt(s, 10) : Number(s);
      return Number.isFinite(n) ? n : null;
    };
    body.execution = body.execution || {};
    body.execution.max_orders_per_run = parseMaybeNone(document.getElementById('maxOrdersInput')?.value, true);
    body.execution.max_single_order_notional_usd = parseMaybeNone(document.getElementById('maxSingleInput')?.value, false);
    body.execution.max_total_notional_usd = parseMaybeNone(document.getElementById('maxTotalInput')?.value, false);
    body.execution.use_limit_orders = String(document.getElementById('useLimitOrdersSelect')?.value || 'false') === 'true';
    body.execution.limit_offset_bps = Number(document.getElementById('limitOffsetInput')?.value || '10');
    body.execution.extended_hours = String(document.getElementById('extendedHoursSelect')?.value || 'false') === 'true';
    body.execution.extended_hours_start_time_local = String(document.getElementById('extendedStartTimeInput')?.value || '06:00');
    body.execution.fallback_to_market_at_open = String(document.getElementById('fallbackEnableSelect')?.value || 'false') === 'true';
    body.execution.fallback_time_local = String(document.getElementById('fallbackTimeInput')?.value || '06:30');
    body.scheduling = body.scheduling || {};
    body.scheduling.weekly_rebalance_day = String(document.getElementById('weeklyRebalanceDaySelect')?.value || 'MON').toUpperCase();

    status.textContent = 'saving…';
    const r = await fetch('/api/config' + (token ? ('?token=' + encodeURIComponent(token)) : ''), {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(body)
    });
    if (!r.ok) {
      const t = await r.text();
      throw new Error(r.status + ' ' + t);
    }
    // Refresh effective config shown in editor after save.
    const fresh = await getJSON('/api/config');
    const ed = document.getElementById('configEditor');
    if (ed) {
      ed.value = JSON.stringify(fresh, null, 2);
      ed.dataset.loaded = '1';
    }
    status.textContent = 'saved';
  } catch (e) {
    status.textContent = 'error: ' + e;
  }
}

document.getElementById('saveBtn')?.addEventListener('click', (e) => {
  e.preventDefault();
  saveConfig();
});

async function cancelAllOpenOrders() {
  const status = document.getElementById('cancelStatus');
  try {
    const token = document.getElementById('token')?.value || '';
    status.textContent = 'canceling…';
    const r = await fetch('/api/cancel-all-open-orders' + (token ? ('?token=' + encodeURIComponent(token)) : ''), {
      method: 'POST'
    });
    if (!r.ok) {
      const t = await r.text();
      throw new Error(r.status + ' ' + t);
    }
    status.textContent = 'canceled';
  } catch (e) {
    status.textContent = 'error: ' + e;
  }
}

document.getElementById('cancelAllBtn')?.addEventListener('click', (e) => {
  e.preventDefault();
  if (confirm('Cancel ALL open orders on this Alpaca paper account?')) {
    cancelAllOpenOrders();
  }
});

let actionJobId = null;

async function runDashboardAction(kind, extraBody={}) {
  const el = document.getElementById('runActionStatus');
  const token = document.getElementById('token')?.value || '';
  try {
    el.textContent = 'starting ' + kind + '…';
    const r = await fetch('/api/actions/run' + (token ? ('?token=' + encodeURIComponent(token)) : ''), {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({kind, place_orders: kind==='rebalance', ...extraBody})
    });
    if (!r.ok) throw new Error(await r.text());
    const j = await r.json();
    actionJobId = j.job_id;
    el.textContent = kind + ' started: ' + actionJobId.slice(0,8);
  } catch (e) {
    el.textContent = 'error: ' + e;
  }
}

async function pollActionJob() {
  if (!actionJobId) return;
  const el = document.getElementById('runActionStatus');
  try {
    const st = await getJSON('/api/actions/status?job_id=' + encodeURIComponent(actionJobId));
    if (st.state === 'running' || st.state === 'starting') {
      el.textContent = `${st.kind||'action'} ${st.state}…`;
      return;
    }
    if (st.state === 'done') {
      el.textContent = `${st.kind||'action'} done`;
      actionJobId = null;
      main().catch(()=>{});
      return;
    }
    if (st.state === 'error') {
      el.textContent = `${st.kind||'action'} error: ${st.error||'unknown'}`;
      actionJobId = null;
      return;
    }
  } catch {}
}

document.getElementById('runPaperRebalanceBtn')?.addEventListener('click', (e) => {
  e.preventDefault();
  if (!confirm('Run paper rebalance now and place orders?')) return;
  runDashboardAction('rebalance');
});

document.getElementById('runScheduledRebalanceBtn')?.addEventListener('click', (e) => {
  e.preventDefault();
  if (!confirm('Queue paper rebalance to run at configured scheduling.weekly_rebalance_time_local?')) return;
  runDashboardAction('rebalance', {wait_until_configured: true});
});

document.getElementById('runRiskCheckBtn')?.addEventListener('click', (e) => {
  e.preventDefault();
  runDashboardAction('risk-check');
});

async function doCron(action) {
  const el = document.getElementById('cronStatusText');
  const token = document.getElementById('token')?.value || '';
  try {
    el.textContent = action + '…';
    const r = await fetch('/api/scheduler/cron/' + action + (token ? ('?token=' + encodeURIComponent(token)) : ''), {method:'POST'});
    if (!r.ok) throw new Error(await r.text());
    const st = await getJSON('/api/scheduler/cron-status');
    el.textContent = st.enabled ? 'cron: enabled' : 'cron: disabled';
    main().catch(()=>{});
  } catch (e) {
    el.textContent = 'error: ' + e;
  }
}

document.getElementById('cronSetupBtn')?.addEventListener('click', (e)=>{ e.preventDefault(); doCron('setup'); });
document.getElementById('cronRestartBtn')?.addEventListener('click', (e)=>{ e.preventDefault(); doCron('restart'); });
document.getElementById('cronStopBtn')?.addEventListener('click', (e)=>{ e.preventDefault(); if(confirm('Disable SeaTrader cron schedules?')) doCron('stop'); });

document.getElementById('btRun')?.addEventListener('click', (e) => {
  e.preventDefault();
  runBacktest().catch(err => {
    document.getElementById('btStatus').textContent = 'error: ' + err;
  });
});

document.getElementById('btRunIter')?.addEventListener('click', async (e) => {
  e.preventDefault();
  if (!confirm('Run strict sequential iteration now? This launches one backtest at a time.')) return;
  try {
    await runBacktestIteration();
  } catch (err) {
    document.getElementById('btStatus').textContent = 'iteration error: ' + (err?.message || err);
  }
});

document.getElementById('btIterExportCsv')?.addEventListener('click', (e) => {
  e.preventDefault();
  exportIterationCsv();
});

document.getElementById('btIterReportLoad')?.addEventListener('click', async (e) => {
  e.preventDefault();
  const id = document.getElementById('btIterReportSel')?.value || '';
  if (!id) return;
  try {
    await loadIterationReportById(id);
  } catch (err) {
    document.getElementById('btStatus').textContent = 'load report error: ' + (err?.message || err);
  }
});

document.getElementById('btTradeSearch')?.addEventListener('input', () => {
  if (window.__lastBacktestRes) {
    renderBacktest(window.__lastBacktestRes).catch(()=>{});
  }
});

document.getElementById('btLedgerSearch')?.addEventListener('input', () => {
  if (window.__lastBacktestRes) {
    renderBacktest(window.__lastBacktestRes).catch(()=>{});
  }
});

document.getElementById('btPreset1y')?.addEventListener('click', (e) => {
  e.preventDefault();
  setBacktestDatesYears(1);
});

document.getElementById('btPreset5y')?.addEventListener('click', (e) => {
  e.preventDefault();
  setBacktestDatesYears(5);
});

document.getElementById('btClearCache')?.addEventListener('click', async (e) => {
  e.preventDefault();
  if (!confirm('Delete cached bar data? Next backtest will refetch.')) return;
  const status = document.getElementById('btStatus');
  try {
    const token = document.getElementById('token')?.value || '';
    status.textContent = 'clearing cache…';
    const r = await fetch('/api/backtest/clear-cache' + (token ? ('?token=' + encodeURIComponent(token)) : ''), {method:'POST'});
    if (!r.ok) throw new Error(await r.text());
    status.textContent = 'cache cleared';
  } catch (err) {
    status.textContent = 'error clearing cache: ' + err;
  }
});

setInterval(() => {
  main().catch(() => {});
  pollBacktest().catch(() => {});
  pollActionJob().catch(() => {});
}, 10_000);
</script>
</body>
</html>
